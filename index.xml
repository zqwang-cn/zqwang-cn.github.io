<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wang&#39;s blog</title>
    <link>https://zqwang-cn.github.io/</link>
    <description>Wang&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2023, zqwang; All rights reserved.</copyright>
    <lastBuildDate>Wed, 13 Dec 2023 18:02:02 +0800</lastBuildDate><atom:link href="https://zqwang-cn.github.io/index.xml" rel="self" type="application/rss+xml" />
      <item>
        <title>基础 - 序列化</title>
        <link>https://zqwang-cn.github.io/qlib-code-analysis/serializable/</link>
        <pubDate>Wed, 13 Dec 2023 12:16:27 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-code-analysis/serializable/</guid>
        <description>在Qlib中，类qlib.utils.serial.Serializable是所有可序列化类（包括DataHandler、DataSet、Processor、Model等）的基类。
该类提供了以下方法进行序列化/反序列化：
config：设置哪些属性需要/不需要序列化 to_pickle：将对象序列化为文件 load：类方法，将文件反序列化为对象 general_dump：类方法，序列化任意对象。对于本类对象，调用其to_pickle方法；对于非本类对象，直接使用pickle进行序列化 该类使用以下机制灵活地控制每个属性是否需要序列化：
_is_kept方法：判断一个属性是否需要序列化。规则如下（按优先级排序）： 如果属性在self.config_attr中，不需要序列化 如果属性在self._get_attr_list(&amp;ldquo;include&amp;rdquo;)中，需要序列化 如果属性在self._get_attr_list(&amp;ldquo;exclude&amp;rdquo;)中，不需要序列化 如果self.dump_all为真，需要序列化 如果属性以下划线开头，不需要序列化 config_attr字段：永远不会序列化此列表中的属性。默认为[&amp;quot;_include&amp;quot;, &amp;ldquo;_exclude&amp;rdquo;] _get_attr_list方法：获取需要序列化与不需要序列化的属性列表 _include与include_attr字段：需要序列化的属性列表。前者存在时返回前者，不存在时返回后者 _exclude与exclude_attr字段：不需要序列化的属性列表。前者存在时返回前者，不存在时返回后者 dump_all属性：表示是否序列化所有属性，为否则只序列化不以下划线开头的属性（优先级最低） _dump_all字段：dump_all属性的底层字段。默认为default_dump_all default_dump_all：默认情况下是否序列化所有属性。默认为否 该类提供以下字段/方法用于选择序列化后端：
pickle_backend字段：序列化后端名称。目前可为pickle或dill get_backend方法：类方法，获取当前序列化后端 此外，该类实现了以下方法供序列化后端调用，以完成实际的序列化/反序列化工作：
__getstate__：获取所有需要序列化的属性 __setstate__：设置所有需要反序列化的属性 </description>
      </item>
    
      <item>
        <title>智能指针</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/smart-pointers/</link>
        <pubDate>Tue, 30 May 2023 21:27:12 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/smart-pointers/</guid>
        <description>C++11标准废弃了原来的智能指针auto_ptr，同时引入了三个新的智能指针：unique_ptr, shared_ptr与weak_ptr。它们基于RAII原则进行内存管理。
RAII（资源获取即初始化） C++中可以在栈上或堆上申请内存，栈上申请的内存会在超出作用域时自动释放，但是堆上申请的内存需要手动释放，否则会出现内存泄漏。在现代C++中，通常基于RAII原则编写代码，以避免出现内存泄漏。
RAII的基本原则是：尽可能在栈上申请资源，如果由于资源太大或其它原因必须在堆上申请时，则该资源需要由一个栈上的对象持有；在该对象初始化时即获取该资源，同时在该对象的析构函数中释放该资源。在超出持有资源对象的作用域时，其析构函数会被自动调用，进而释放所持有的资源，从而避免了内存泄漏。
unique_ptr 特点 unique_ptr对象持有一个底层指针，在unique_ptr对象析构时会自动释放该指针。通过禁用拷贝构造函数与拷贝赋值操作符，unique_ptr保证此底层指针只有一个持有者。如需转移底层指针的所有权，可以使用移动语义，移动后原unique_ptr失效。
在确定同时只能有一个所有者的情况下，使用unique_ptr可以在编译期间即保证此约束，从而避免运行期间出现错误，同时可以简化代码逻辑并提高运行效率。
实现 在unique_ptr类中，至少需要实现以下功能：
普通构造函数：保存传入的指针 析构函数：释放持有的指针 拷贝构造函数/赋值操作符：禁止使用，避免多个持有者 移动构造函数/赋值操作符：实现底层指针所有权的转移 *与-&amp;gt;操作符：实现与普通指针相同的操作 一个简单的实现如下：
template &amp;lt;typename T&amp;gt; class unique_ptr { public: // 普通构造函数，保存传入的指针 unique_ptr(T *p = nullptr) : ptr_(p) {} // 析构函数 ~unique_ptr() { // 底层指针非空则释放 if (ptr_) { delete ptr_; ptr_ = nullptr; } } // 禁用拷贝构造函数与赋值操作符，保证只有一个所有者 unique_ptr(const unique_ptr &amp;amp;) = delete; unique_ptr &amp;amp;operator=(const unique_ptr &amp;amp;) = delete; // 移动构造函数 unique_ptr(unique_ptr &amp;amp;&amp;amp;p) { // 保存底层指针 ptr_ = p.</description>
      </item>
    
      <item>
        <title>一、变量与常量</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/variables-and-constants/</link>
        <pubDate>Thu, 16 Mar 2023 23:37:05 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/variables-and-constants/</guid>
        <description>变量 变量绑定 使用let语句将字面值或另一变量绑定至一个变量。Rust是静态类型语言，每个变量的类型在编译期就已经确定，变量类型可以手动指定也可由编译器推断。
// 将字面值绑定至变量 let an_integer = 1u32; // 将另一变量绑定至此变量 let copied_integer = an_integer; 可变性 基本上所有的语言中，变量默认都是可变的。但是在Rust中，为了达到最大的安全性，变量默认为不可变的，如需使用可变变量，需要使用mut显示声明。
// 声明不可变变量 let immutable_binding = 1; // 错误，不可修改不可变变量 immutable_binding += 1 // 声明可变变量 let mut mutable_binding = 1; // 修改可变变量 mutable_binding += 1; 作用域 每个变量有其作用域，它被限制为只在其所在代码块中有效。
fn main() { // 此变量在整个main函数内有效 let long_lived_binding = 1; // 此代码块的作用域小于main函数 { // 此变量只在当前代码块中有效 let short_lived_binding = 2; // 正确 println!(&amp;#34;inner short: {}&amp;#34;, short_lived_binding); } // 代码块结束 // 错误，超出作用域，无法使用此变量 println!</description>
      </item>
    
      <item>
        <title>简介</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/introduction/</link>
        <pubDate>Tue, 07 Mar 2023 21:42:20 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/introduction/</guid>
        <description> 简介 Qlib是一个面向人工智能的量化研究平台，主要用于进行基于人工智能(机器学习/深度学习/强化学习)算法的量化策略的研究。
使用Qlib，用户可以简单地测试他们的想法并建立更好的量化投资策略。
框架 Qlib是一个由以上模块构成的平台。这些模块被设计为松耦合，每个模块可以单独使用。
框架主要分为4层：
基础设施层：提供量化研究的底层支持 学习框架层：用于训练可训练模型，支持监督学习与强化学习两类 工作流层：覆盖量化研究的整个工作流 接口层：为用户提供友好的接口 </description>
      </item>
    
      <item>
        <title>数据 - 数据集</title>
        <link>https://zqwang-cn.github.io/qlib-code-analysis/dataset/</link>
        <pubDate>Wed, 13 Dec 2023 18:02:02 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-code-analysis/dataset/</guid>
        <description>Dataset qlib.data.dataset.Dataset类是所有数据集类的基类。该类未实现任何实际功能，只设计了基本接口。该类是Serializable类的子类，因此所有数据集都可以序列化。
在该类的设计中，一个数据集对象可以根据参数返回不同的分片（如训练集/测试集等），因此该类将数据的准备过程拆分为两个方法：
setup_data：进行整个数据集的准备工作，如从硬盘加载数据等。不返回数据 prepare：根据参数准备不同分片的数据，对数据进行预处理并返回 该类的其它方法有：
__init__：初始化对象。会调用setup_data方法 config：配置对象 DatasetH qlib.data.dataset.DatasetH类表示带有数据处理器的数据集，它是Dataset类的子类。
在数据集的使用过程中，有以下两个常见的问题：
在绝大部分情况下，数据集本身的操作完全相同，只是不同的底层数据需要进行不同的预处理操作。如果将预处理操作放在数据集类中进行，则对于每类数据都需要实现一个新的数据集类，这显然没有必要 prepare方法被设计为根据参数准备分片数据。对于金融数据，一般根据时间范围进行分片，但是如果每次调用prepare方法都传入时间范围则显得比较多余且容易出错 为了解决以上两个问题，该类进行了以下两点设计：
将数据预处理操作与数据集类解耦，交由数据处理器负责，这样就无需重复实现数据集类。需要注意的是，如果有一些特殊的预处理操作，如：与特定模型相关的操作或与数据分片相关的操作，则仍需实现自定义数据集类 预先定义好所有可能的分片名称与对应的时间范围，这样在调用prepare方法时就可以直接使用分片名称作为参数 成员变量：
handler：数据处理器
segments：数据集分片信息，格式如下：
{ &amp;#39;train&amp;#39;: (&amp;#34;2008-01-01&amp;#34;, &amp;#34;2014-12-31&amp;#34;), &amp;#39;valid&amp;#39;: (&amp;#34;2017-01-01&amp;#34;, &amp;#34;2020-08-01&amp;#34;,), &amp;#39;test&amp;#39;: (&amp;#34;2015-01-01&amp;#34;, &amp;#34;2016-12-31&amp;#34;,), } 核心方法：
prepare：准备数据。根据参数中的分片名称获取相应的时间范围，并调用_prepare_seg生成每个分片的数据 _prepare_seg：准备一个分片的数据。根据时间范围调用数据处理器的fetch方法获取一个分片的数据 setup_data：准备原始数据。调用数据处理器的同名方法 其它方法：
__init__：初始化对象。必须传入数据处理器与数据分片信息 config：配置对象 帮助方法（静态）：
_get_extrema：获取数据极值 get_min_time：获取最小时间 get_max_time：获取最大时间 TSDatasetH qlib.data.dataset.TSDatasetH类表示带有数据处理器的时序数据集，该类是DatasetH类的子类。
DatasetH类用于返回原始的表格数据（格式一般为pandas.DataFrame），表格数据中存储了每个标的在每个时间点的特征数据。而TSDatasetH类用于返回时序数据，每个标的在每个时间点的时序数据是由该时间点及之前一段时间的原始数据组成的序列。
成员变量：
step_len：每个时间点的时序数据中包含的原始数据长度 核心方法：
prepare：准备数据。继承自父类，不作修改 _prepare_seg：准备一个分片的数据。使用父类同名方法获取需要使用的原始数据，之后封装为TSDataSampler类对象并返回 setup_data：准备原始数据 其它方法：
__init__：初始化对象。可以设置step_len（默认为DEFAULT_STEP_LEN） config：配置对象。可以设置step_len _extend_slice：静态方法。将时序数据的起止时间扩展为所依赖的原始数据的起止时间 TSDataSampler qlib.data.dataset.TSDataSampler类表示时序数据采样器，它是TSDatasetH类prepare方法的返回结果。
该类通过索引机制获取时序数据，其接口格式与torch.data.utils.Dataset类似，包含以下方法：
__len__：获取数据集大小 __getitem__：根据索引获取时序数据 其中索引可以为以下两种形式之一：
整数：例如tsds[len(tsds) - 1] 时间点-标的对：例如tsds[&#39;2016-12-31&#39;, &amp;quot;SZ300315&amp;quot;] 由于每个时间点的时序数据都包含之前一段时间的原始数据，因此相邻时间点的时序数据中存在大量重复的原始数据，此时如果储存全部时序数据会出现严重的冗余。为了解决这个问题，该类只存储原始数据，在每次检索时根据传入的索引获取原始数据、动态构建时序数据并返回。用户传入的原始数据通常是索引为&amp;quot;时间点-标的对&amp;quot;的pd.DataFrame格式数据，为了加快检索速度，该类在初始化时将索引顺序掉换为&amp;quot;标的-时间点对&amp;quot;，并将数据格式转换为np.ndarray。
储存转换后的原始数据的字段为：
data_arr：np.ndarray类型。转换后的原始数据 由于np.ndarray类型不包含索引，因此该类使用以下字段储存从索引到原始数据位置的映射：</description>
      </item>
    
      <item>
        <title>快速开始</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/quickstart/</link>
        <pubDate>Tue, 21 Nov 2023 15:19:34 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/quickstart/</guid>
        <description>安装 使用pip安装最新的稳定版本： pip install pyqlib 如需使用最新的开发版本，可以从源码安装： # 安装依赖 pip install numpy pip install --upgrade cython # 下载源码并安装 git clone https://github.com/microsoft/qlib.git &amp;amp;&amp;amp; cd qlib pip install . 数据准备 Qlib提供了一个获取股票数据的脚本。该数据是通过爬虫从雅虎财经网站上获取的，质量较低。如需使用高质量数据，需要用户自行准备。
通过python模块获取数据 # 获取日线数据 python -m qlib.run.get_data qlib_data --target_dir ~/.qlib/qlib_data/cn_data --region cn # 获取分钟线数据 python -m qlib.run.get_data qlib_data --target_dir ~/.qlib/qlib_data/cn_data_1min --region cn --interval 1min 通过代码获取数据 # 获取日线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/cn_data --region cn # 获取分钟线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/cn_data_1min --region cn --interval 1min 自动量化研究工作流 Qlib提供了一个工具程序qrun，可以根据配置文件自动运行整个工作流（包括建立数据集、训练模型、回测与评估），并得到图形报表分析。</description>
      </item>
    
      <item>
        <title>右值引用</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/rvalue-reference/</link>
        <pubDate>Sat, 03 Jun 2023 15:51:24 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/rvalue-reference/</guid>
        <description>左值与右值 C++03标准 C++03标准中将表达式分为左值与右值，并且非左即右：
左值：表达式结束后依然存在的持久对象，可以出现在赋值号的左侧与右侧，可以寻址 右值：表达式结束后就不再存在的临时对象，只可以出现在赋值号的右侧，不可寻址 C++11标准 C++11对左值、右值的分类重新进行了定义，在C++11标准中，表达式有以下两个属性：
有身份：指代某个非临时对象 可被移动：可被右值引用类型匹配 根据以上两个属性可以得到4种组合：
有身份，不可移动：左值，与C++03中的左值相同 无身份，可移动：纯右值，与C++03中的右值相同 有身份，可移动：将亡值，即生命周期即将结束的值，为C++11中新增加的类型 无身份，不可移动：无意义 将亡值与纯右值合称为右值。
右值引用 C++11之前的引用类型全部为左值引用，用&amp;amp;符号声明。一般来说，左值引用必须绑定左值：
// num为左值 int num = 10; // 正确，a为左值num的引用 int &amp;amp;a = num; // 错误，10为右值，不能使用左值引用绑定 int &amp;amp;b = 10; 但是有个例外，可以将const左值引用绑定至右值：
const int &amp;amp;c = 10; C++11中添加了右值引用类型，用&amp;amp;&amp;amp;符号声明，右值引用只能绑定右值：
// num为左值 int num = 10; // 错误，右值引用不能绑定左值 int &amp;amp;&amp;amp;a = num; // 正确，右值引用绑定纯右值 int &amp;amp;&amp;amp;b = 10; 右值引用的主要作用是用于实现移动语义与完美转发。
移动语义 在没有右值引用之前，C++中只存在“拷贝语义”，通过使用拷贝构造函数或拷贝赋值运算符（它们的参数为左值引用）可以将一个对象进行拷贝：
class A { public: A() {} ~A() {} // 拷贝构造函数 A(const A &amp;amp;rhs) {} // 拷贝赋值运算符 A &amp;amp;operator=(const A &amp;amp;rhs) { return *this; } }; int main() { A a1; // 使用拷贝构造函数进行对象拷贝 A a2(a1); A a3 = a1; // 使用拷贝赋值运算符进行对象拷贝 A a4; a4 = a1; } 此时，如果要将一个即将析构的对象赋值给一个新对象，仍然需要先进行拷贝再进行析构，这样运行效率较低。由于原对象即将析构，因此可以将其中的资源移动至新对象，从而减少一次资源复制。</description>
      </item>
    
      <item>
        <title>二、所有权与借用</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/ownership-and-borrowing/</link>
        <pubDate>Fri, 17 Mar 2023 19:43:21 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/ownership-and-borrowing/</guid>
        <description>RAII（资源获取即初始化） 为了能够正常释放资源，避免出现C/C++中很容易出现的资源泄漏，Rust强制执行RAII。RAII要求任何对象在离开其作用域时，必须调用其析构函数并释放资源。Rust中的析构函数通过Drop特性实现。
fn create_box() { // 在函数中申请堆上资源 let _box1 = Box::new(3i32); // 函数结束时释放_box1 } fn main() { // 在主函数中申请堆上资源 let _box2 = Box::new(5i32); { // 在一个代码块中申请堆上资源 let _box3 = Box::new(4i32); // 代码块结束时释放_box3 } // 申请很多资源，无需手动释放 for _ in 0u32..1_000 { create_box(); } // 主函数结束时释放_box2 } 所有权与移动语义 所有权：为了能够安全地释放资源，Rust引入了所有权规则：
每个变量有且只能有一个所有者 在退出作用域时，所有者负责释放资源 这避免了多次释放同一资源，另外也有一些变量不拥有资源（即引用）。
移动语义：默认情况下，在使用let进行赋值，或者向函数传递参数时，所有权会进行转移。在进行移动后，原来的变量不能再使用，这避免了悬挂指针。
// 此函数获取堆上资源的所有权 fn destroy_box(c: Box&amp;lt;i32&amp;gt;) { println!(&amp;#34;Destroying a box that contains {}&amp;#34;, c); // 函数结束时c被释放 } // 栈上资源只会进行复制 let x = 5u32; let y = x; // 堆上资源会进行移动，移动后a不能再使用 let a = Box::new(5i32); let b = a; // 调用函数将b的所有权移动到函数中，移动后b不能再使用 destroy_box(b); 可变性变化 变量的可变性在移动时可以进行变化。</description>
      </item>
    
      <item>
        <title>基础 - 工作流</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/workflow/</link>
        <pubDate>Wed, 22 Nov 2023 10:08:34 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/workflow/</guid>
        <description>简介 Qlib中设计了很多模块/组件，在进行实验时需要将多个组件组成一个工作流。组成工作流的方式有两种：
使用python代码将组件组合成工作流（例子) 使用Qlib提供的qrun程序，它可以根据配置文件自动运行整个工作流 一个完整的qrun工作流包括以下步骤：
数据 加载 处理 切片 模型 训练与推理 保存与加载 评估 预测信号分析 回测 Qlib还有一套完整的记录系统用于记录训练、推理与评估阶段的所有信息与结果。
完整例子 下面是qrun的一个典型的配置文件，定义了量化研究的典型工作流：
qlib_init: provider_uri: &amp;#34;~/.qlib/qlib_data/cn_data&amp;#34; region: cn market: &amp;amp;market csi300 benchmark: &amp;amp;benchmark SH000300 data_handler_config: &amp;amp;data_handler_config start_time: 2008-01-01 end_time: 2020-08-01 fit_start_time: 2008-01-01 fit_end_time: 2014-12-31 instruments: *market port_analysis_config: &amp;amp;port_analysis_config strategy: class: TopkDropoutStrategy module_path: qlib.contrib.strategy.strategy kwargs: topk: 50 n_drop: 5 signal: &amp;lt;PRED&amp;gt; backtest: limit_threshold: 0.095 account: 100000000 benchmark: *benchmark deal_price: close open_cost: 0.0005 close_cost: 0.0015 min_cost: 5 task: model: class: LGBModel module_path: qlib.</description>
      </item>
    
      <item>
        <title>函数对象与lambda表达式</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/function-object-and-lambda-expression/</link>
        <pubDate>Mon, 05 Jun 2023 20:29:17 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/function-object-and-lambda-expression/</guid>
        <description>函数对象 函数对象（仿函数/函子）指实现了operator()运算符的类的对象，它的调用方式与函数类似。相对于直接函数调用，函数对象有两个优势：
函数对象可包含状态 函数对象是一个类型，因此可用作模板参数 class Plus { public: int operator()(int a, int b) { return a + b; } }; int main() { Plus plus; int n = plus(11, 22); } lambda表达式 lambda表达式是C++11引入的一个语法糖，使用它可以方便快捷地创建一个匿名函数对象。
int main() { auto plus = [](int a, int b) { return a + b; }; int n = plus(11, 22); } 组成 一个完整lambda表达式的组成如下：
[ capture-list ] ( params ) mutable(optional) exception(optional) -&amp;gt; ret(optional) { body } 捕获列表（capture-list） 参数列表（params） mutable标识（mutable，可选） 异常标识（exception，可选） 返回类型（ret，可选） 函数体（body） 其中，参数列表、异常标识、返回类型、函数体4部分都与函数基本相同，其它部分说明如下：</description>
      </item>
    
      <item>
        <title>三、控制流</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/control-flow/</link>
        <pubDate>Sat, 18 Mar 2023 00:49:56 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/control-flow/</guid>
        <description>分支语句（if-else） 分支语句if-else的用法基本与其它语言相同。
// 单独使用if，使用if-else，或者使用if-else if-else等均可 if n &amp;lt; 0 { print!(&amp;#34;{} is negative&amp;#34;, n); } else if n &amp;gt; 0 { print!(&amp;#34;{} is positive&amp;#34;, n); } else { print!(&amp;#34;{} is zero&amp;#34;, n); } // if-else语句是表达式，可以作为值使用，但是所有分支的返回值类型必须相同 let big_n = if n &amp;lt; 10 &amp;amp;&amp;amp; n &amp;gt; -10 { println!(&amp;#34;, and is a small number, increase ten-fold&amp;#34;); 10 * n } else { println!(&amp;#34;, and is a big number, halve the number&amp;#34;); n / 2 }; 循环语句 无限循环（loop） 无限循环语句，只能使用break或return退出。</description>
      </item>
    
      <item>
        <title>基础 - 数据框架</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/data-framework/</link>
        <pubDate>Wed, 22 Nov 2023 11:48:12 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/data-framework/</guid>
        <description>简介 Qlib的数据框架提供了友好的API用于管理与检索数据，以及高性能的数据基础设施。它是专门为量化投资设计的，例如，用户可以轻松地建立公式化alpha。
下面是使用Qlib数据工作流的一个典型的例子：
下载基础数据并转换为Qlib格式（后缀名为.bin） 使用Qlib表达式引擎建立一些基本特征，例如Ref($close, 60) / $close表示最近60个交易日的回报率。这一步骤通常实现在数据处理器中的数据加载器组件内 如果用户需要更加复杂的数据处理（如数据归一化），数据处理器模块支持用户自定义处理器。处理器可以实现表达式引擎难以支持的复杂数据处理方法 基于预处理的数据生成模型所需的数据集 数据预处理 Qlib格式数据 Qlib专门设计了一种数据结构用于处理金融数据，此类数据被存储于.bin文件中。
Qlib提供了两个现成的数据集：
数据集 美国市场 中国市场 Alpha360 √ √ Alpha158 √ √ 同时Qlib也提供了一个高频数据集。
Qlib格式数据集 Qlib提供脚本scripts/get_data.py用于下载数据集。使用如下命令下载中国市场股票数据集：
# 下载日线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/cn_data --region cn # 下载分钟线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/qlib_cn_1min --region cn --interval 1min 也可以下载美国市场股票数据集：
python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/us_data --region us 运行上述命令后，中国市场与美国市场股票数据集分别保存于~/.qlib/qlib_data/cn_data和~/.qlib/qlib_data/us_data目录中。
Qlib也提供一个脚本scripts/data_collector帮助用户爬取最新数据并转换为Qlib格式。
自动更新数据 强烈建议用户先手动更新数据一次，之后设置为自动更新：
手动更新数据 python scripts/data_collector/yahoo/collector.py update_data_to_bin --qlib_data_1d_dir &amp;lt;user data dir&amp;gt; --trading_date &amp;lt;start date&amp;gt; --end_date &amp;lt;end date&amp;gt; 其中参数trading_date为交易开始日期，end_date为交易结束日期（不包含）。</description>
      </item>
    
      <item>
        <title>std::function与std::bind</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/std-function-and-std-bind/</link>
        <pubDate>Mon, 05 Jun 2023 20:57:03 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/std-function-and-std-bind/</guid>
        <description>std::function 类模板std::function是通用多态函数封装器。std::function的实例能存储、复制及调用任何可调用目标，包括：
函数/函数指针 函数对象 lambda表达式 成员函数指针 数据成员指针 作用 调用者可使用统一的方式调用可调用目标，无需关心绑定的具体类型 一种类型的std::function对象可绑定多种类型的可调用目标，实现多态的效果（例如用于回调函数） 例子 struct Foo { Foo(int num) : num_(num) {} void print_add(int i) const { std::cout &amp;lt;&amp;lt; num_ + i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } int num_; }; void print_num(int i) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } struct PrintNum { void operator()(int i) const { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } }; int main() { // 存储函数 std::function&amp;lt;void(int)&amp;gt; f1 = print_num; f1(-9); // 存储lambda表达式 std::function&amp;lt;void()&amp;gt; f2 = []() { print_num(42); }; f2(); // 存储std::bind的结果 std::function&amp;lt;void()&amp;gt; f3 = std::bind(print_num, 31337); f3(); // 存储成员函数指针 std::function&amp;lt;void(const Foo &amp;amp;, int)&amp;gt; f4 = &amp;amp;Foo::print_add; const Foo foo(314159); f4(foo, 1); f4(314159, 1); // 存储数据成员指针 std::function&amp;lt;int(Foo const &amp;amp;)&amp;gt; f5 = &amp;amp;Foo::num_; std::cout &amp;lt;&amp;lt; f5(foo) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; // 存储成员函数指针，绑定对象 using std::placeholders::_1; std::function&amp;lt;void(int)&amp;gt; f6 = std::bind(&amp;amp;Foo::print_add, foo, _1); f6(2); // 存储成员函数指针，绑定对象指针 std::function&amp;lt;void(int)&amp;gt; f7 = std::bind(&amp;amp;Foo::print_add, &amp;amp;foo, _1); f7(3); // 存储函数对象 std::function&amp;lt;void(int)&amp;gt; f8 = PrintNum(); f8(18); } std::bind std::bind函数将可调用目标与指定参数进行绑定，并以函数对象的形式保存。调用此函数对象相当于使用绑定的参数调用原可调用目标。如果有的参数不能在绑定时确定，可以使用std::placeholders中的占位符占位，并延迟到调用时再传入。</description>
      </item>
    
      <item>
        <title>四、函数与闭包</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/functions-and-closures/</link>
        <pubDate>Sun, 19 Mar 2023 00:40:01 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/functions-and-closures/</guid>
        <description>函数 函数使用fn关键字声明，如有需要，则指定参数名称与类型，以及返回值的类型。返回方式除了可以使用return外，还可以在最后一条语句给出一个表达式。
fn add_one(x: i32) -&amp;gt; i32 { x + 1 } 语句与表达式 Rust程序由语句组成，常见的语句有let语句与表达式语句 代码块也是表达式，它的最后一个表达式被返回。需要注意的是，如果最后一个表达式以分号结尾，则返回值为() 函数指针 函数指针的类型是fn，在使用时还需要指定输入输出类型。
fn do_twice(f: fn(i32) -&amp;gt; i32, arg: i32) -&amp;gt; i32 { f(arg) + f(arg) } // 将add_one函数指针作为do_twice的参数 let answer = do_twice(add_one, 5); 函数指针fn是一个类型，所以在作为参数时可以直接使用，而无需使用泛型并使用闭包特性进行限制。此外，fn实现了全部3种闭包特性（Fn，FnMut与FnOnce），这意味着可以将函数指针传给所有将闭包作为参数的函数。因此，在写函数时最好使用泛型与闭包特性，这样函数与闭包都可以作为参数。
但是，在与外部代码交互时，可能只接收函数指针作为参数。
闭包 闭包是可以捕获环境中变量的函数，相当于lambda表达式。
// 一个捕获了变量x的闭包 |val| val + x 闭包的特点有：
使用||代替() 如果只有一条语句可以省略{} 可以捕获环境中的变量 捕获变量 闭包可以捕获环境中的变量。可以通过以下3种方式：
引用：&amp;amp;T 可变引用：&amp;amp;mut T 值：T // 引用捕获 let color = String::from(&amp;#34;green&amp;#34;); let print = || println!(&amp;#34;`color`: {}&amp;#34;, color); print(); // 可变引用捕获 let mut count = 0; let mut inc = || { count += 1; println!</description>
      </item>
    
      <item>
        <title>基础 - 模型</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/model/</link>
        <pubDate>Thu, 23 Nov 2023 09:43:29 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/model/</guid>
        <description>简介 模型用于计算股票的预测分数。Qlib提供了基类Model，所有模型都必须继承它；另外还提供了基类ModelFT，包含了用于微调的方法。
例子 Qlib的模型库中包含了LightGBM、MLP、LSTM等模型，它们被视为基线模型。下面的例子展示了如何将LightGBM作为独立模块使用：
from qlib.contrib.model.gbdt import LGBModel from qlib.contrib.data.handler import Alpha158 from qlib.utils import init_instance_by_config, flatten_dict from qlib.workflow import R from qlib.workflow.record_temp import SignalRecord, PortAnaRecord market = &amp;#34;csi300&amp;#34; benchmark = &amp;#34;SH000300&amp;#34; data_handler_config = { &amp;#34;start_time&amp;#34;: &amp;#34;2008-01-01&amp;#34;, &amp;#34;end_time&amp;#34;: &amp;#34;2020-08-01&amp;#34;, &amp;#34;fit_start_time&amp;#34;: &amp;#34;2008-01-01&amp;#34;, &amp;#34;fit_end_time&amp;#34;: &amp;#34;2014-12-31&amp;#34;, &amp;#34;instruments&amp;#34;: market, } task = { &amp;#34;model&amp;#34;: { &amp;#34;class&amp;#34;: &amp;#34;LGBModel&amp;#34;, &amp;#34;module_path&amp;#34;: &amp;#34;qlib.contrib.model.gbdt&amp;#34;, &amp;#34;kwargs&amp;#34;: { &amp;#34;loss&amp;#34;: &amp;#34;mse&amp;#34;, &amp;#34;colsample_bytree&amp;#34;: 0.8879, &amp;#34;learning_rate&amp;#34;: 0.0421, &amp;#34;subsample&amp;#34;: 0.8789, &amp;#34;lambda_l1&amp;#34;: 205.6999, &amp;#34;lambda_l2&amp;#34;: 580.9768, &amp;#34;max_depth&amp;#34;: 8, &amp;#34;num_leaves&amp;#34;: 210, &amp;#34;num_threads&amp;#34;: 20, }, }, &amp;#34;dataset&amp;#34;: { &amp;#34;class&amp;#34;: &amp;#34;DatasetH&amp;#34;, &amp;#34;module_path&amp;#34;: &amp;#34;qlib.</description>
      </item>
    
      <item>
        <title>类型推导</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/type-deduction/</link>
        <pubDate>Tue, 06 Jun 2023 21:10:22 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/type-deduction/</guid>
        <description>C++是强类型语言，使用每个变量前必须声明其类型。如果不进行类型推导，则用户必须自行声明所有变量的类型，对于一些复杂的类型（如容器的迭代器）或临时类型（如lambda表达式），这是没有意义甚至无法完成的。为此，C++11标准引入了auto与decltype两个关键字用于进行类型推导，使得编译器可以自动推导出变量的类型。这样做有以下好处：
鲁棒性：即使更改表达式的类型也能正常工作 性能：可以保证没有进行转换 可用性：不必担心类型名称拼写困难或拼写有误 效率：代码会变得更高效 auto 在C++11之前，auto关键字为存储期说明符，但是基本不使用。C++11之后将此关键字用于类型推导，其基本语法是：
auto 变量名 初始化器; 基本用法 // 通用初始化语法 auto a{42}; // 赋值语法 auto b = 0; // 通用赋值语法，它结合了上述两种形式 auto c = {3.14159}; // 直接初始化或构造函数样式的语法 auto d(1.41421f); // 通过表达式推导 auto e = 1 + 2; // 通过函数返回值推导 auto f = add(1, 1.2); // 推导new操作符结果 auto g = new auto(10); // 推导lambda表达式类型 auto lambda1 = [](int x) { return x + 3; }; // 可在一行定义多个变量，但是不能出现冲突 auto x = a, &amp;amp;y = b, *z = &amp;amp;e; // C++14后可自动推导函数返回值 auto func() { return 2 + 3; } // C++14后可自动推导lambda函数的参数 auto lambda2 = [](auto a) { return a; }; // C++17后可自动推导非类型模板参数 template &amp;lt;auto I&amp;gt; struct A; // 在for循环中使用 auto vec = std::vector&amp;lt;int&amp;gt;(); for (auto it = vec.</description>
      </item>
    
      <item>
        <title>五、类型</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/types/</link>
        <pubDate>Mon, 20 Mar 2023 23:37:45 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/types/</guid>
        <description>内置类型 标量类型 有符号整型：i8, i16, i32, i64, i128, isize 无符号整型：u8, u16, u32, u64, u128, usize 浮点型：f32, f64 字符型：char（4字节Unicode字符） 布尔型：bool（true/false） unit类型：类型为()，有且仅有一个值()。类似void 复合类型 复合类型有元组与数组两种，它们的长度与其中变量的类型在声明后均不可变。
元组：由多个不同类型的变量组成 let x: (i32, f64, u8) = (-1, 2.0, 3); // 声明元组 let a = x.0; // 取元组中的元素 let (a, b, c) = x; // 解构 数组：由多个同一类型的变量组成 let a: [i32; 5] = [1, 2, 3, 4, 5]; // 声明数组 let a = [3; 5]; // 使用同一变量初始化 let x = a[0]; // 取数组中的元素 切片：使用切片可以更加方便地操作序列数据，但是它本身不包含数据，只是一种引用，包含起始位置与长度两个字段 let a: [i32; 5] = [1, 2, 3, 4, 5]; // 声明数组 let s: &amp;amp;[i32] = &amp;amp;a[1.</description>
      </item>
    
      <item>
        <title>基础 - 投资组合策略</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/portfolio-strategy/</link>
        <pubDate>Thu, 23 Nov 2023 10:39:32 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/portfolio-strategy/</guid>
        <description>简介 投资组合策略可以根据模型的预测分数生成投资组合。Qlib提供了一些已实现的投资组合策略，同时也支持用户根据需要进行自定义。在确定了模型（预测信号）与策略后，运行回测可以检查它们的性能。
基类 BaseStrategy 此类是所有策略类的基类，用户可以继承此类并实现其接口以添加自定义策略。其接口有：
generate_trade_decision：一个关键接口，用于在每个交易周期生成交易决策。其调用频率取决于执行器，但是实际交易频率可以由用户代码控制 WeightStrategyBase 此类只专注于目标仓位，并基于仓位自动生成订单。其接口有：
generate_target_weight_position 根据当前仓位与交易日期生成目标仓位（不考虑现金） 返回目标仓位（所有资产的百分比） 该类按照如下方式实现了generate_order_list接口：
调用generate_target_weight_position方法生成目标仓位 根据目标仓位生成股票的目标数量 根据股票的目标数量生成订单 已实现的策略 TopkDropoutStrategy 该类按照如下方式实现了generate_order_list接口：
执行Topk-Drop算法计算每支股票的目标数量 根据股票的目标数量生成订单 EnhancedIndexingStrategy 该策略将主动管理与被动管理相结合，目标是在控制风险敞口的同时取得超出基准指数的收益。
例子 预测分数 预测分数是一个pandas的DataFrame对象，它的索引是&amp;lt;datetime(pd.Timestamp), instrument(str)&amp;gt;且必须包含分数列。一个例子如下：
datetime instrument score 2019-01-04 SH600000 -0.505488 2019-01-04 SZ002531 -0.320391 2019-01-04 SZ000999 0.583808 2019-01-04 SZ300569 0.819628 2019-01-04 SZ001696 -0.137140 ... ... 2019-04-30 SZ000996 -1.027618 2019-04-30 SH603127 0.225677 2019-04-30 SH603126 0.462443 2019-04-30 SH603133 -0.302460 2019-04-30 SZ300760 -0.126383 注意预测分数不一定是收益率，不同模型有不同的定义。
运行回测 大多数情况下，用户可以使用backtest_daily回测他们的投资组合策略： from pprint import pprint import qlib import pandas as pd from qlib.</description>
      </item>
    
      <item>
        <title>const与constexpr</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/const-and-constexpr/</link>
        <pubDate>Wed, 07 Jun 2023 01:08:48 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/const-and-constexpr/</guid>
        <description>const C++11之前就存在const关键字，用于进行常量相关操作。它的主要用法如下：
// 定义常量，使其不能修改 const int value = 5; // 可以使用常量定义数组 char arr[value]; char s[10]; // 指针不可修改，指向的内容可修改 char *const ptr1 = s; // 指针可修改，指向的内容不可修改 const char *ptr2; // 指针与指向的内容均不可修改 const char *const ptr3 = &amp;#34;string&amp;#34;; // 修饰函数参数，使其不可修改，如果同时使用引用可避免复制对象 void func(const A &amp;amp;a); // 修饰成员变量，使其不能修改，只能进行初始化 class A { const int value = 5; }; class B { const int value; B(int v) : value(v) {} }; // 修饰成员函数，使其不能修改成员变量 class C { public: void func() const {} }; // 修饰对象，使其只能调用const成员函数 const C c; c.</description>
      </item>
    
      <item>
        <title>六、泛型</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/generics/</link>
        <pubDate>Tue, 21 Mar 2023 14:00:03 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/generics/</guid>
        <description>泛型是用于编写功能确定，类型待定的代码模板的机制，可以有效减少代码冗余。类似于C++中的模板。
在函数中使用 // 定义一个使用泛型的函数 fn foo&amp;lt;T&amp;gt;(arg: T) { ... } // 编译器自动识别T为i32 foo(1); // 编译器自动识别T为&amp;amp;str foo(&amp;#34;string&amp;#34;); // 手动设置T为i32 foo::&amp;lt;i32&amp;gt;(1); 在结构体中使用 // 定义一个使用泛型的结构体 struct Point&amp;lt;T&amp;gt; { x: T, y: T, } // 自动识别T为i32 let integer = Point { x: 5, y: 10 }; // 自动识别T为f64 let float = Point { x: 1.0, y: 4.0 }; // 错误，x与y必须具有相同的类型 let wont_work = Point { x: 5, y: 4.0 }; // 手动设置T为u8 let uint8 = Point::&amp;lt;u8&amp;gt; { x: 1, y: 2 }; 在枚举中使用 std库中的Option与Result是非常常用的使用了泛型的枚举结构。</description>
      </item>
    
      <item>
        <title>基础 - 实验管理系统</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/experiment-management/</link>
        <pubDate>Thu, 23 Nov 2023 14:44:47 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/experiment-management/</guid>
        <description>简介 Qlib包含一个实验管理系统，名为QlibRecorder，它可以帮助用户高效地管理实验与分析结果。该系统有三个组件：
实验管理器：用于管理实验 实验：每个实例代表一个实验 记录器：每个实例负责记录一次实验运行 该系统定义了一系列接口，还提供了一个具体的实现MLflowExpManager，该实现基于机器学习平台MLFlow。如果用户使用了该实现，则可以使用命令mlflow ui来可视化与检查实验结果。
QlibRecorder QlibRecorder为用户提供了一套高级API来使用实验管理系统，该接口被封装为R，用户可以直接使用R与系统交互。导入R的代码如下：
from qlib.workflow import R QlibRecorder还包括一些公用API用来在工作流中管理实验与记录器。
实验管理器 ExpManager ExpManager模块负责管理不同的实验，大部分API与QlibRecorder相同，其中最重要的API是get_exp方法。
实验 Experiment Experiment类负责处理与一个实验相关的所有操作，其中包括开始、结束实验等基本方法，以及与记录器相关的方法，如get_recorder和list_recorders。
Qlib提供了一个默认的实验，在某些特定情况下，如用户调用log_metrics或get_exp等API时，该实验被自动创建并使用。如果使用默认实验，则会产生相关的日志信息。用户可以在配置文件中或初始化时修改默认实验的名称。
记录器 Recorder Recorder类负责在一次实验运行中帮助用户方便地跟踪实验结果以及生成的其它信息。
记录模板 RecordTemp RecordTemp类用于按照指定格式生成实验结果。Qlib提供了三个记录模板类：
SignalRecord：生成模型的预测结果 SigAnaRecord：生成模型的IC/ICIR/Rank IC/Rank ICIR from qlib.contrib.eva.alpha import calc_ic, calc_long_short_return ic, ric = calc_ic(pred.iloc[:, 0], label.iloc[:, 0]) long_short_r, long_avg_r = calc_long_short_return(pred.iloc[:, 0], label.iloc[:, 0]) PortAnaRecord：生成回测结果 from qlib.contrib.strategy.strategy import TopkDropoutStrategy from qlib.contrib.evaluate import ( backtest as normal_backtest, risk_analysis, ) # 回测 STRATEGY_CONFIG = { &amp;#34;topk&amp;#34;: 50, &amp;#34;n_drop&amp;#34;: 5, } BACKTEST_CONFIG = { &amp;#34;limit_threshold&amp;#34;: 0.</description>
      </item>
    
      <item>
        <title>枚举</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/enumeration/</link>
        <pubDate>Wed, 07 Jun 2023 23:54:06 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/enumeration/</guid>
        <description>无作用域枚举（enum） C++11之前存在的枚举为无作用域枚举，使用enum关键字声明：
enum Color { red, green, blue }; 每个枚举项都成为该枚举类型的一个具名常量，在它的外围作用域可见，且可以用于要求常量的任何位置：
Color r = red; 每个枚举类型都有一个底层类型，可以显式指定底层类型：
enum smallenum : std::int16_t { a, b, c }; 可以在枚举项列表中提供初始化器，各枚举项的值由那些初始化器所定义。如果首个枚举项无初始化器，那么它的关联值为零。对于其他任何定义中无初始化器的枚举项，它的关联值是前一枚举项加一：
enum Foo { a, b, c = 10, d, e = 1, f, g = f + c }; 无作用域枚举类型的值可隐式转换到整型类型：
int n = blue; 无作用域枚举的名字可以忽略：
enum { a, b, c = 0, d = a + 2 }; 使用无作用域枚举可能产生以下问题：
由于枚举项在任何作用域可见，因此容易与其它变量名称产生冲突 由于枚举项可隐式转换到整型类型，因此有时会发生未预期的转换 有作用域枚举（enum class或enum struct） C++11引入新的有作用域枚举，使用enum class或enum struct关键字声明：</description>
      </item>
    
      <item>
        <title>七、特性</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/traits/</link>
        <pubDate>Wed, 22 Mar 2023 17:50:53 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/traits/</guid>
        <description>特性是为未知类型Self定义的一组方法，类似于Java的接口。特性可以为任意类型实现，包括内置类型，如i64/&amp;amp;str等。
定义特性 // 定义一个特性，无需实现 pub trait Summary { fn summarize(&amp;amp;self) -&amp;gt; String; } // 定义特性时可以提供默认实现 pub trait Summary { fn summarize(&amp;amp;self) -&amp;gt; String { String::from(&amp;#34;(Read more...)&amp;#34;) } } 实现特性 特性必须为某个类型实现，可以认为是为这个类型添加了相应的方法。
impl Summary for NewsArticle { fn summarize(&amp;amp;self) -&amp;gt; String { format!(&amp;#34;{}, by {} ({})&amp;#34;, self.headline, self.author, self.location) } } 使用impl Trait impl Trait是一个语法糖，它相当于在泛型函数中使用泛型范围（trait bound）。可以将impl Trait作为函数的输入参数或者返回值，使代码更简洁易读，但是需要注意此时的函数是静态泛型函数，并不能动态接收或返回不同的类型。
作为输入参数 // 使用impl Trait作为输入参数 pub fn notify(item: &amp;amp;impl Summary) { println!(&amp;#34;Breaking news! {}&amp;#34;, item.summarize()); } // 使用+表示参数需要实现多个特性 pub fn notify(item: &amp;amp;(impl Summary + Display)) {} 作为返回值 // 使用impl Trait作为返回值 fn returns_summarizable() -&amp;gt; impl Summary {} 使用dyn返回实现特性的动态类型 Rust编译器必须知道函数返回值占用空间的大小，但是对于同样一个特性，不同的实现类型占用空间不同，因此不能直接将特性作为返回值。但是，可以通过返回一个Box指向一个实现特性的变量来解决这一问题。由于Box大小确定，因此这是可行的。由于Rust要求在堆上分配内存时必须显示说明，因此这种情况下需要使用dyn关键字。</description>
      </item>
    
      <item>
        <title>基础 - 图形分析</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/analysis/</link>
        <pubDate>Thu, 23 Nov 2023 16:01:57 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/analysis/</guid>
        <description> 简介 本模块用于展示日内交易的图形报表，从而帮助用户从视觉上评估与分析投资组合。下面是一些可用报表：
analysis_position：仓位分析 report_graph：回测报表 score_ic_graph：分数IC报表 cumulative_return_graph：累积回报率报表 risk_analysis_graph：风险分析报表 rank_label_graph：排名标签报表 analysis_model：模型分析 model_performance_graph：模型性能报表 所有图形报表 使用如下代码获取所有支持的报表：
&amp;gt;&amp;gt; import qlib.contrib.report as qcr &amp;gt;&amp;gt; print(qcr.GRAPH_NAME_LIST) [&amp;#39;analysis_position.report_graph&amp;#39;, &amp;#39;analysis_position.score_ic_graph&amp;#39;, &amp;#39;analysis_position.cumulative_return_graph&amp;#39;, &amp;#39;analysis_position.risk_analysis_graph&amp;#39;, &amp;#39;analysis_position.rank_label_graph&amp;#39;, &amp;#39;analysis_model.model_performance_graph&amp;#39;] </description>
      </item>
    
      <item>
        <title>列表初始化</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/list-initialization/</link>
        <pubDate>Thu, 08 Jun 2023 00:42:33 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/list-initialization/</guid>
        <description>列表初始化是使用花括号初始化器对变量进行初始化的方式。C++11之前只能用于数组等少量类型，C++11后将这种方式推广至所有类型。
初始化非类类型 // 不使用列表初始化 int a; // 默认初始化，值不确定 int b = int(); // 零初始化 int c(1); // 直接初始化 int d = 1; // 复制初始化 // 使用列表初始化 int e{}; // 零初始化 int f{1}; // 直接初始化 int g = {1}; // 复制初始化 int h = int{1}; // 直接初始化临时量，然后复制初始化 // 列表初始化引用 const int &amp;amp;r1 = {1}; // 绑定const左值引用到临时变量 int &amp;amp;&amp;amp;r2 = {1}; // 绑定右值引用到临时变量 int &amp;amp;r3 = {2}; // 错误，不能绑定右值到非const左值引用 初始化类类型 初始化聚合类型 聚合类型是下列类型之一：</description>
      </item>
    
      <item>
        <title>八、标准库 - 常用集合类型</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-common-collections/</link>
        <pubDate>Thu, 23 Mar 2023 12:51:57 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-common-collections/</guid>
        <description>Vec Vec是长度可变的数组，它在堆上分配空间，且能自动进行内存管理，类似于C++的std::vector。一个Vec包含3个参数：
数据指针 长度 容量 // 建立空Vec let v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // 使用初始值建立Vec let v = vec![1, 2, 3]; // 添加值 v.push(4); // 获取值 let third: &amp;amp;i32 = &amp;amp;v[2]; let third: Option&amp;lt;&amp;amp;i32&amp;gt; = v.get(2); // 迭代值 for i in &amp;amp;v { println!(&amp;#34;{i}&amp;#34;); } for i in &amp;amp;mut v { *i += 50; } String String是在堆上分配空间的动态字符串类型（区别于内置静态字符串类型&amp;amp;str），类似于C++的std::string。String底层存储使用Vec&amp;lt;u8&amp;gt;类型，但是保证总是有效的UTF8编码字符串。因此String中每个字符的大小不一致，需要小心使用。
// 建立空String let mut s = String::new(); // 将&amp;amp;str转换为String let s = &amp;#34;initial contents&amp;#34;.</description>
      </item>
    
      <item>
        <title>元组与结构化绑定</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/tuple-and-structured-binding/</link>
        <pubDate>Thu, 08 Jun 2023 21:49:57 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/tuple-and-structured-binding/</guid>
        <description>元组 有时需要将多个不同类型的变量聚合为一个新类型，虽然使用类或结构体即可实现此功能，但是它们都需要提前声明并指定一个类型名称。很多情况下用户并不会重复使用该类型，或者并不关心该类型的名称，但是希望能够更加简单地实现该功能。为了解决此问题，C++11中引入了元组。元组类模板std::tuple是固定大小的异类值汇集。它是std::pair的泛用形式。
std::tuple&amp;lt;int, std::string, double&amp;gt; t1; // 用默认值初始化 std::tuple&amp;lt;int, std::string, double&amp;gt; t2{42, &amp;#34;Test&amp;#34;, -3.14}; // 列表初始化 std::tuple&amp;lt;char, std::string, int&amp;gt; t3{t2}; // 隐式转换 std::tuple&amp;lt;int, double&amp;gt; t4{std::make_pair(42, 3.14)}; // 从pair创建 auto t5 = std::make_tuple(1, 2.0f, 3.14, &amp;#34;string&amp;#34;); // 使用make_tuple创建 auto t6 = std::tuple_cat(t1, t2, t3); // 拼接元组 int size = std::tuple_size&amp;lt;decltype(t1)&amp;gt;::value; // 获取元素个数 int a = std::get&amp;lt;0&amp;gt;(t1); // 提取单个元素 std::get&amp;lt;0&amp;gt;(t1) = 0; // 修改单个元素 int a1; std::string b1; double c1; std::tie(a1, b1, c1) = t1; // 解包元素 const auto [a2, b2, c2] = t2; // 结构化绑定 结构化绑定 结构化绑定用于将一组变量绑定至一个复合结构的所有子元素上，该复合结构可以为数组、元组或结构体。虽然也可以使用赋值语句逐一进行绑定，但是结构化绑定极大地简化了这一操作。</description>
      </item>
    
      <item>
        <title>九、标准库 - 智能指针</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-smart-pointers/</link>
        <pubDate>Fri, 24 Mar 2023 13:53:31 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-smart-pointers/</guid>
        <description>Box Box是最简单的智能指针，它在堆上分配内存。Box只能有一个持有者，类似于C++的std::unique_ptr。Box没有性能开销，同时也没有额外功能。一般在以下情况下使用
要使用一个在编译期无法知道大小的类型 要转换大量数据的所有权但是不想拷贝数据 要使用实现了某个特性，但并不关心其具体类型的类型 // 声明一个Box并储存一个值 let a = Box::new(5); // 取Box中储存的值（解引用，需要实现Deref特性） let b = *a; // 强制解引 println!(&amp;#34;a = {}&amp;#34;, a); // 提前释放内存（可自动释放，需要实现Drop特性） drop(a); Rc Rc是带引用计数的智能指针，可以有多个持有者，类似于C++的std::shared_ptr。
// 声明一个Rc并储存一个值 let rc_a: Rc&amp;lt;String&amp;gt; = Rc::new(&amp;#34;Rc examples&amp;#34;.to_string()); // 复制指针（底层数据不变，引用计数+1） let rc_b: Rc&amp;lt;String&amp;gt; = Rc::clone(&amp;amp;rc_a); // 查看引用计数 println!(&amp;#34;Reference Count of rc_a: {}&amp;#34;, Rc::strong_count(&amp;amp;rc_a)); // 判断两个Rc是否指向同一数据 println!(&amp;#34;rc_a and rc_b are equal: {}&amp;#34;, rc_a.eq(&amp;amp;rc_b)); // 通过Rc直接使用底层数据的方法 println!(&amp;#34;Length of the value inside rc_a: {}&amp;#34;, rc_a.</description>
      </item>
    
      <item>
        <title>类中的新特性</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/new-features-in-class/</link>
        <pubDate>Thu, 08 Jun 2023 23:06:07 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/new-features-in-class/</guid>
        <description>委托构造 同一个类中的一个构造函数可以调用另一个构造函数，从而达到简化代码的目的：
class Base { public: Base() { value1 = 1; } Base(int value) : Base() // 委托Base()构造函数 { value2 = 2; } private: int value1; int value2; }; 继承构造 假设父类有多个版本的构造函数，即使子类不进行修改，也必须编写同样多的构造函数，将参数透传至父类，例如：
class A { public: A(int i) {} A(double d, int i) {} A(float f, int i, const char *c) {} //...... }; class B : public A { public: B(int i) : A(i) {} B(double d, int i) : A(d, i) {} B(float f, int i, const char *c) : A(f, i, c) {} //.</description>
      </item>
    
      <item>
        <title>十、标准库 - 并发</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-concurrency/</link>
        <pubDate>Sat, 25 Mar 2023 23:12:30 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-concurrency/</guid>
        <description>安全并高效地处理并发是Rust的主要目标之一。Rust使用所有权与类型系统可以同时处理内存安全与并发安全问题。
线程（Thread） // 使用spawn建立线程，使其运行一个闭包 let handle = thread::spawn(|| { for i in 1..10 { println!(&amp;#34;hi number {} from the spawned thread!&amp;#34;, i); } }); // 使用join等待线程结束 handle.join().unwrap(); // 使用sleep令当前线程休眠 thread::sleep(Duration::from_millis(1)); // 为了使线程闭包能够使用外部变量，需要使用move关键字移动所有权 let v = vec![1, 2, 3]; let handle = thread::spawn(move || { println!(&amp;#34;Here&amp;#39;s a vector: {:?}&amp;#34;, v); }); 通道 通过消息传递来进行安全的并发是一种越来越流行的思想。因此Rust标准库中实现了通道，它可以由sender发送数据给receiver。
// 建立通道，获得sender与receiver let (tx, rx) = mpsc::channel(); // 在新线程中使用sender发送数据，注意需要将sender移动至新线程 thread::spawn(move || { let val = String::from(&amp;#34;Hi&amp;#34;); // 为了保证安全，使用通道发送数据时，数据被移动 tx.</description>
      </item>
    
      <item>
        <title>std::optional、std::variant与std::any</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/optional-variant-any/</link>
        <pubDate>Fri, 09 Jun 2023 00:37:27 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/optional-variant-any/</guid>
        <description>C++17中提出了以下三种数据类型用于更加安全、方便地处理可变数据。
std::optional 类模板std::optional管理一个可选的容纳值，该值既可以存在也可以不存在。虽然直接使用指针就可以实现相同的功能，但是容易引发内存泄漏或二次释放等问题。其它实现方式（如使用std::pair&amp;lt;T,bool&amp;gt;）语法复杂且效率低下，而std::optional可以简单、高效地处理此问题。
// 初始化为不包含值 std::optional&amp;lt;int&amp;gt; opt1; std::optional&amp;lt;int&amp;gt; opt2(std::nullopt); std::optional&amp;lt;int&amp;gt; opt3 = std::nullopt; // 初始化为包含值 std::optional&amp;lt;int&amp;gt; op4(1); std::optional&amp;lt;int&amp;gt; op5 = 2; std::optional&amp;lt;int&amp;gt; op6 = std::make_optional&amp;lt;int&amp;gt;(3); // 判断是否包含值 if (opt1.has_value()) { // 可使用*或-&amp;gt;操作符访问包含的值，但是需要自行判断是否包含值 std::cout &amp;lt;&amp;lt; &amp;#34;opt1: &amp;#34; &amp;lt;&amp;lt; *opt1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } // 实现了bool运算符，表示是否包含值 if (opt1) { std::cout &amp;lt;&amp;lt; &amp;#34;opt1: &amp;#34; &amp;lt;&amp;lt; *opt1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } // 使用value成员函数获取包含的值，如果不包含值则抛出异常 try { int n = opt1.value(); } catch (const std::exception &amp;amp;e) { std::cout &amp;lt;&amp;lt; e.</description>
      </item>
    
      <item>
        <title>十一、标准库 - 其它</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-misc/</link>
        <pubDate>Sun, 26 Mar 2023 17:07:48 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-misc/</guid>
        <description>路径 使用std::path中的Path与PathBuf表示系统路径。其中Path是不可变版本，PathBuf为可变版本。
// 建立Path后不可变 let path = Path::new(&amp;#34;.&amp;#34;); // 从字符串建立PathBuf let mut buf = PathBuf::from(&amp;#34;.&amp;#34;); // 将Path转换为PathBuf let mut buf = path.to_path_buf(); // 修改PathBuf buf.push(&amp;#34;a&amp;#34;); buf.push(&amp;#34;b.txt&amp;#34;); buf.set_file_name(&amp;#34;c.tar&amp;#34;); buf.set_extension(&amp;#34;zip&amp;#34;); 文件I/O // 打开文件用于读取 let mut file = File::open(&amp;amp;path).unwrap(); // 读取文件内容到String let mut s = String::new(); file.read_to_string(&amp;amp;mut s).unwrap(); // 建立文件用于写入 let mut file = File::create(&amp;amp;path).unwrap(); // 将字符串写入文件 file.write_all(&amp;#34;content&amp;#34;.as_bytes()).unwrap(); 子进程 使用std::process::Command执行命令建立子进程。可以使用管道与其交互，等待执行完成并获取返回值。
let output = Command::new(&amp;#34;rustc&amp;#34;) // 要执行的命令 .arg(&amp;#34;--version&amp;#34;) // 参数 .output() // 等待执行完毕并获取结果 .</description>
      </item>
    
      <item>
        <title>形参包</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/parameter-pack/</link>
        <pubDate>Fri, 09 Jun 2023 20:58:23 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/parameter-pack/</guid>
        <description>模板形参包是接受零个或多个模板实参（非类型、类型或模板）的模板形参。函数模板形参包是接受零个或多个函数实参的函数形参。至少有一个形参包的模板被称作变参模板。
定义 变参类模板可用任意数量的模板实参实例化：
template &amp;lt;class... Types&amp;gt; struct Tuple {}; Tuple&amp;lt;&amp;gt; t0; // Types不包含实参 Tuple&amp;lt;int&amp;gt; t1; // Types包含一个实参：int Tuple&amp;lt;int, float&amp;gt; t2; // Types包含两个实参：int与float Tuple&amp;lt;0&amp;gt; error; // 错误：0不是类型 变参函数模板可用任意数量的函数实参调用（模板实参通过模板实参推导规则进行推导）：
template &amp;lt;class... Types&amp;gt; void f(Types... args) {} f(); // args不包含实参 f(1); // args包含一个实参：int f(2, 1.0); // args包含两个实参：int与double 在类模板中，模板形参包必须是模板形参列表的最后一个形参。在函数模板中，模板参数包可以在列表中稍早出现，只要其后的所有形参均可从函数实参推导或拥有默认实参即可：
// 正确，Ts在结尾 template &amp;lt;typename U, typename... Ts&amp;gt; struct valid; // 错误，Ts不在结尾 template &amp;lt;typename... Ts, typename U&amp;gt; struct invalid; // 正确，可以推导U template &amp;lt;typename... Ts, typename U, typename = void&amp;gt; void valid(U, Ts.</description>
      </item>
    
      <item>
        <title>十二、错误处理</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/error-handling/</link>
        <pubDate>Mon, 27 Mar 2023 11:35:30 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/error-handling/</guid>
        <description>panic 最简单的错误处理方式是使用panic!宏，它简单地打印错误并退出程序。
panic!(&amp;#34;crash and burn&amp;#34;); abort/unwind 处理panic有两种方式，可以通过编译器参数或配置文件的方式设置。默认为unwind
unwind：回溯调用栈并进行清理工作 abort：立即退出 Option 在Rust中，如果一个函数返回类型T，则它必须返回一个变量，不能返回空（类似NULL或nullptr），这样可以避免用户不检查空指针造成错误。如果确实需要返回空，则可以使用Option。Option是std库提供的一个枚举类型。Option&amp;lt;T&amp;gt;的取值为以下二者之一：
Some(T)：包含一个T类型的元素 None：不包含任何元素 编译器会强制用户处理值为None的情况，从而提高安全性。Option的操作方式有：
match：与其它枚举的处理方式相同，需要处理所有可能情况 解包：为Some时获取其值，为None时执行不同操作 unwrap：为None时panic expect：为None时使用自定义信息报错 ?：为None时使当前所在函数返回None or：为None时返回另一值。链式、立即 or_else：为None时调用函数获取值并返回。链式、延迟 get_or_insert：为None时插入值。立即 get_or_insert_with：为None时调用函数获取值并插入。延迟 使用combinator进行后续操作： map：有值则对其进行操作，否则返回None and_then：有值则解包其值并进行操作，否则返回None Result Option只返回了错误，但是并不知道错误的原因。Result加强了这一点。一个Result&amp;lt;T, E&amp;gt;的取值为以下二者之一：
Ok(T)：成功，并返回一个T类型的值 Err(E)：失败，并返回一个E类型错误 Result同样可以使用match, unwrap, ?, map, and_then等进行操作。</description>
      </item>
    
      <item>
        <title>文件系统库</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/filesystem-lib/</link>
        <pubDate>Fri, 09 Jun 2023 22:11:36 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/filesystem-lib/</guid>
        <description>C++17从boost引入了文件系统库std::filesystem，提供在文件系统及其组件，例如路径、常规文件与目录上进行操作的方法。
path 类型path的对象表示文件系统上的路径，其中包含许多对路径进行操作的成员函数。
namespace fs = std::filesystem; fs::path p1 = &amp;#34;/path/to/file&amp;#34;; // 使用字符序列构造路径 fs::path p2(&amp;#34;/path/to/dir&amp;#34;); // 使用字符序列构造路径 fs::path p3(p1); // 复制构造路径 p3 = &amp;#34;/path/to/another/file&amp;#34;; // 赋值 p2 /= &amp;#34;dir1&amp;#34;; // 使用/=拼接路径，加入分隔符 p2 += &amp;#34;dir2&amp;#34;; // 使用+=拼接路径，不加入分隔符 fs::path p4 = p2 / &amp;#34;dir3&amp;#34;; // 使用/拼接路径，加入分隔符 p1.filename(); // 获取文件名 p2.stem(); // 获取文件名主干部分（不含扩展名） p3.extension(); // 获取扩展名 p1.has_filename(); // 检查filename()是否为空 p2.has_stem(); // 检查stem()是否为空 p3.has_extension(); // 检查extension()是否为空 p1.remove_filename(); // 删除文件名 p2.replace_filename(&amp;#34;foo&amp;#34;); // 替换文件名 p3.replace_extension(&amp;#34;.bar&amp;#34;); // 替换扩展名 p1.</description>
      </item>
    
      <item>
        <title>十三、迭代器</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/iterators/</link>
        <pubDate>Tue, 28 Mar 2023 17:38:06 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/iterators/</guid>
        <description> 使用迭代器处理系列数据 使用迭代器可以对一系列数据依次进行处理。直到使用迭代器时，它不产生任何影响。
let v1 = vec![1, 2, 3]; // 获取Vec的迭代器 let v1_iter = v1.iter(); // 在for-in循环中使用迭代器 for val in v1_iter { println!(&amp;#34;Got: {}&amp;#34;, val); } 迭代器特性 迭代器需要实现类似如下的特性：
pub trait Iterator { type Item; fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;; } 消耗适配器 指会消耗掉迭代器的方法，调用这些方法后就不能再使用迭代器。
let v1 = vec![1, 2, 3]; let v1_iter = v1.iter(); let total: i32 = v1_iter.sum(); 迭代器适配器 指会生成其它迭代器的方法，它们并不消耗原来的迭代器。
let v1: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3]; v1.iter().map(|x| x + 1); </description>
      </item>
    
      <item>
        <title>日期时间库</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/datetime-lib/</link>
        <pubDate>Fri, 09 Jun 2023 23:16:33 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/datetime-lib/</guid>
        <description>std::chrono是源于boost的C++新时间库，其中包含3个主要类型以及一些辅助函数。
时间间隔 类模板std::chrono::duration用于表示时间间隔。其定义如下：
template&amp;lt; class Rep, class Period = std::ratio&amp;lt;1&amp;gt; &amp;gt; class duration; 其中，Rep为计次数的算术类型，可为整型、浮点型；Period为计次周期，为分数类型（std::ratio），单位为秒。例如，如果Period为std::ratio&amp;lt;1, 1000&amp;gt;，则表示计次周期为毫秒。每个duration对象包含一个Rep类型的次数，可用count()成员函数获取。次数×周期即为duration对象表示的时间间隔。常用的duration类型已经预定义：
nanoseconds：duration&amp;lt;至少64位的有符号整数类型, std::nano&amp;gt; microseconds：duration&amp;lt;至少55位的有符号整数类型, std::micro&amp;gt; milliseconds：duration&amp;lt;至少45位的有符号整数类型, std::milli&amp;gt; seconds：duration&amp;lt;至少35位的有符号整数类型, std::ratio&amp;lt;1&amp;gt;&amp;gt; minutes：duration&amp;lt;至少29位的有符号整数类型, std::ratio&amp;lt;60&amp;gt;&amp;gt; hours：duration&amp;lt;至少23位的有符号整数类型, std::ratio&amp;lt;3600&amp;gt;&amp;gt; 其中，std::nano为std::ratio&amp;lt;1, 1000000000&amp;gt;，std::micro为std::ratio&amp;lt;1, 1000000&amp;gt;，std::milli为std::ratio&amp;lt;1, 1000&amp;gt;。C++20还添加了days、weeks、months和years。
// 10秒 std::chrono::seconds ten_seconds(10); // 5小时 std::chrono::hours five_hours(5); 时间间隔字面值 C++14中添加了一些字面值后缀操作符，可以方便地生成时间间隔字面值：
h：小时 min：分钟 s：秒 ms：毫秒 us：微妙 ns：纳秒 using namespace std::chrono_literals; auto two_hours = 2h; auto five_minutes = 5min; 时间间隔转换 不同单位的时间间隔之间可以相互转换，转换规则为：
当整数时间间隔相互转换且源间隔单位可被目标间隔单位整除，或浮点时间间隔相互转换时，不会发生精度损失，可使用duration类的构造函数隐式转换 浮点时间间隔转整数时间间隔时，如果浮点值为NaN，无穷或相对整数间隔单位来说过大时，会出现未定义行为 其它情况（浮点时间间隔转整数时间间隔，或整数时间间隔相互转换但源间隔单位不能被目标间隔单位整除）下，会发生截断造成精度损失，情况与static_cast相同 // high_resolution_clock使用最小时间单位，且为整数时间间隔 auto t1 = std::chrono::high_resolution_clock::now(); // .</description>
      </item>
    
      <item>
        <title>十四、模式与匹配</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/patterns-and-matching/</link>
        <pubDate>Wed, 29 Mar 2023 21:42:31 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/patterns-and-matching/</guid>
        <description>模式是Rust的一种特殊语法，用于对类型的结构进行匹配。一个模式由若干以下项组成：
字面值 解构的数组、枚举、结构体或元组 变量 通配符 占位符 在模式有效的范围内，它描述了数据的形状。程序将值与模式进行匹配，以确定它是否有正确的形状，并决定是否进一步执行一段代码。
可以使用模式的位置 match分支 在match中使用模式要求穷举所有可能性，一种保证穷举的方法是在最后一个分支处理所有剩余所有可能性。使用_可以匹配任何可能性并且不绑定值，所以一般用在最后一个分支。
match x { None =&amp;gt; None, Some(i) =&amp;gt; Some(i + 1), } if-let条件表达式 if-let/else-if/else-if-let可以混用。使用if-let的缺点是如果不在最后使用else，则不能穷举所有情况。
if let Some(color) = favorite_color { println!(&amp;#34;Using your favorite color, {color}, as the background&amp;#34;); } else if is_tuesday { println!(&amp;#34;Tuesday is green day!&amp;#34;); } else if let Ok(age) = age { if age &amp;gt; 30 { println!(&amp;#34;Using purple as the background color&amp;#34;); } else { println!(&amp;#34;Using orange as the background color&amp;#34;); } } else { println!</description>
      </item>
    
      <item>
        <title>并发库</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/thread-and-synchronization/</link>
        <pubDate>Sat, 10 Jun 2023 11:47:09 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/thread-and-synchronization/</guid>
        <description>线程 C++11引入了与操作系统无关的std::thread类，可以使用统一的方式创建线程。C++20提供了std::jthread类，在std::thread的基础上增加了自动合并与外部请求终止的功能。
auto func = []() { for (int i = 0; i &amp;lt; 10; ++i) std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34;; std::cout &amp;lt;&amp;lt; std::endl; }; std::thread t(func); // 创建一个线程并开始执行 if (t.joinable()) // 检查线程可否被合并 t.join(); // 阻塞等待线程结束 if (t.joinable()) t.detach(); // 将线程和线程对象分离，无法再与线程交互 互斥 使用互斥避免多个线程同时访问共享资源，这可以避免数据竞争，并提供线程间的同步支持。
互斥量 C++并发库中提供以下互斥量：
mutex：基本互斥量 timed_mutex：带时限互斥量 recursive_mutex：能被同一线程递归锁定的互斥量 recursive_timed_mutex：带时限且能被同一线程递归锁定的互斥量 shared_mutex：共享互斥量 shared_timed_mutex：带时限共享互斥量 std::mutex mut; // 互斥量 std::vector&amp;lt;int&amp;gt; nums; // 共享变量 auto func = [&amp;amp;](int k) { mut.lock(); // 对互斥量加锁 nums.</description>
      </item>
    
      <item>
        <title>十五、生命周期</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/lifetime/</link>
        <pubDate>Thu, 30 Mar 2023 21:57:18 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/lifetime/</guid>
        <description>生命周期是编译器的借用检查器用来保证所有借用都有效的一个概念。一个变量的生命周期从它被创建开始到它被销毁结束。
fn main() { let i = 3; // i生命周期开始 ─────────────────────────────┐ // │ { // │ let borrow1 = &amp;amp;i; // 借用`borrow1`生命周期开始 ──────┐│ // ││ println!(&amp;#34;borrow1: {}&amp;#34;, borrow1); // ││ } // `borrow1`生命周期结束 ─────────────────────────────┘│ // │ // │ { // │ let borrow2 = &amp;amp;i; // 借用`borrow2`生命周期开始 ──────┐│ // ││ println!(&amp;#34;borrow2: {}&amp;#34;, borrow2); // ││ } // `borrow2`生命周期结束 ─────────────────────────────┘│ // │ } // i生命周期结束 ────────────────────────────────────────┘ 显式标注 借用检查器使用显式生命周期标注来决定引用需要有效多久。
// foo具有一个生命周期参数&amp;#39;a，foo的生命周期不能超过&amp;#39;a foo&amp;lt;&amp;#39;a&amp;gt; // 一个带生命周期标注的类型 &amp;amp;&amp;#39;a T // 使用多个生命周期参数，foo的生命周期不能超过&amp;#39;a或&amp;#39;b foo&amp;lt;&amp;#39;a, &amp;#39;b&amp;gt; 在函数中使用 带有生命周期的函数签名具有一些约束：</description>
      </item>
    
      <item>
        <title>十六、宏</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/macros/</link>
        <pubDate>Fri, 31 Mar 2023 19:32:52 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/macros/</guid>
        <description>分类 Rust中的宏分为两类：使用macro_rules!声明的声明式宏与以下3种过程宏：
自定义#[derive]宏：可以使用derive属性在结构体与枚举上添加指定代码 类属性宏：自定义可以在任何项目上使用的属性 类函数宏：看起来像函数但是在它们的参数上进行操作 为什么使用宏 DRY（不要重复自己）：可以避免重复同样的代码 DSL（领域特定语言）：可以定义用于特定用途的自定义语法 Variadic（可变参数函数）：可以定义接收任意数量参数的接口（类似函数），例如println! 宏与函数的不同 宏是用代码写其它代码的方式，即元编程。在编译前，编译器会将宏展开并进行编译。与C等语言的宏不同，Rust的宏不是简单的字符串展开，而是会生成抽象语法树，这避免了无法预期的问题。宏与函数都是用于减少代码量，但是宏有一些函数没有的能力。
函数必须指定参数的个数与类型，宏可以接收任意数量参数 宏在编译前展开，函数在运行期间调用，所以宏可以做许多函数无法做的事情，例如在一个类型上实现一个特性 宏的缺点是更加复杂，难于理解与维护，因为是在间接地用代码编写代码 宏必须先定义并加引入作用域才能使用，而函数可以在任何地方定义与调用 使用macro_rules!进行元编程的声明式宏 声明式宏允许编写一个类似match的结构，在编译时，如果传入值匹配其中一个分支，则将宏替换为对应的代码。使用macro_rules!定义宏：
// 定义宏 macro_rules! say_hello { () =&amp;gt; { println!(&amp;#34;Hello!&amp;#34;); }; } // 调用宏 say_hello!() 语法 参数与指示符 宏的参数定义方式如下，每个参数带有前缀$，冒号后为其指示符，表示该参数的类型。
($func_name:ident) 可能的指示符有：
block：块 expr：表达式 ident：标识符，如变量、函数名 item：项，如函数、结构体、模块等 literal：字面值常量 pat：模式 path：路径 stmt：语句 tt：语法树 ty：类型 vis：visibility限定词 完整的列表在这里。
重载 宏可以重载，使用不同的参数组合。
macro_rules! test { // 一个参数组合 ($left:expr; and $right:expr) =&amp;gt; { println!(&amp;#34;{:?} and {:?} is {:?}&amp;#34;, stringify!($left), stringify!($right), $left &amp;amp;&amp;amp; $right) }; // 另一个参数组合 ($left:expr; or $right:expr) =&amp;gt; { println!</description>
      </item>
    
      <item>
        <title>十七、不安全操作</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/unsafe-operations/</link>
        <pubDate>Sat, 01 Apr 2023 11:34:52 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/unsafe-operations/</guid>
        <description>Rust编译器的静态检查可以保证代码是非常安全的，但是它过于严格，拒绝了一些可能有效的代码。因此如果确定需要使用这些代码，则要使用不安全操作告诉编译器放松条件。此外，如果要执行一些底层系统级操作，则必须要使用不安全操作。
解引裸指针 引用是由编译器保证总是有效的，因此可以安全地使用。在不安全的Rust中，有两种新的裸指针类型：*const T与*mut T。使用裸指针在放弃了安全性保证的同时，可以得到极大的性能提升或与其它语言/硬件进行交互的能力。与引用和智能指针不同，裸指针有以下特点：
允许忽略借用规则，同时可以有任意个指针指向同一地址 不保证裸指针指向有效数据 可以为空 不实现自动清理 以下代码从引用建立裸指针，可知指向的数据是有效的：
let mut num = 5; // 建立不可变指针 let r1 = &amp;amp;num as *const i32; // 建立可变指针 let r2 = &amp;amp;mut num as *mut i32; 以下代码从任意内存位置建立指针，不能保证指向有效数据：
let address = 0x012345usize; let r = address as *const i32; 建立裸指针本身是安全的，但是由于指向的数据不一定有效，所以解引裸指针是不安全的：
unsafe { println!(&amp;#34;r1 is: {}&amp;#34;, *r1); println!(&amp;#34;r2 is: {}&amp;#34;, *r2); } 调用不安全函数或方法 在函数声明前添加unsafe关键字声明不安全函数，这意味着调用者需要自行保证调用的正确性。调用此类函数需要在unsafe块中进行。
// 声明unsafe函数 unsafe fn dangerous() {} // 调用unsafe函数 unsafe { dangerous(); } 可以将不安全代码封装在安全函数中，无需将整个函数标记为不安全。</description>
      </item>
    
      <item>
        <title>十八、代码组织</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/code-organization/</link>
        <pubDate>Sun, 02 Apr 2023 22:14:35 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/code-organization/</guid>
        <description>Rust提供了一系列特性用于管理代码的组织结构，包括：
Package（包）：Cargo提供的可以建立、测试与分享箱的结构 Crate（箱）：模块组成的树，构成一个库或可执行文件 Module（模块）与use（引入）：用于控制代码结构、作用域与路径的隐私性 Path（路径）：命名结构体、函数或模块的方式 Crate（箱） 箱是编译器每次编译的最小单位。箱分为两类：
二进制箱：是可以编译为可执行文件的程序，包含main函数 库箱：不包含main函数，用于分享功能 每个箱从一个根文件开始编译，可能包含多个文件。
Package（包） 包是包管理器Cargo提供的结构，它包含一个配置文件Cargo.toml。一个包可以包含多个箱，但是最多有一个库箱。默认情况下，src/main.rs是二进制箱的根文件，src/lib.rs是库箱的根文件。
Module（模块） 使用模块可以对代码进行组织以提高可读性与可用性，每个箱都由一组树状的模块组成。
使用以下命令建立一个库：
cargo new restaurant --lib 在src/lib.rs中添加以下代码：
mod front_of_house { mod hosting { fn add_to_waitlist() {} fn seat_at_table() {} } mod serving { fn take_order() {} fn serve_order() {} fn take_payment() {} } } 以上代码形成的模块树如下，其中根自动命名为crate：
crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment Path（路径） 使用路径在模块树中引用项目 路径有两种形式：</description>
      </item>
    
      <item>
        <title>十九、测试</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/tests/</link>
        <pubDate>Mon, 03 Apr 2023 12:54:41 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/tests/</guid>
        <description>测试是检查其它代码是否正常工作的Rust函数。典型的测试函数执行以下三个动作：
设置需要的数据和状态 运行测试代码 检查结果是否符合预期 如何编写测试函数 使用cargo new建立一个库项目时，会自动生成一个测试模块。测试函数前需要添加#[test]属性，之后使用cargo test命令会自动运行测试。
#[cfg(test)] mod tests { #[test] fn it_works() { let result = 2 + 2; assert_eq!(result, 4); } } 使用assert!宏检查结果 assert!用于保证条件为true，为true则继续执行程序，为false则调用panic!。
#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn can_hold(&amp;amp;self, other: &amp;amp;Rectangle) -&amp;gt; bool { self.width &amp;gt; other.width &amp;amp;&amp;amp; self.height &amp;gt; other.height } } #[cfg(test)] mod tests { use super::*; // 此测试会成功 #[test] fn larger_can_hold_smaller() { let larger = Rectangle { width: 8, height: 7, }; let smaller = Rectangle { width: 5, height: 1, }; assert!</description>
      </item>
    
      <item>
        <title>二十、其他</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/others/</link>
        <pubDate>Tue, 04 Apr 2023 13:26:25 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/others/</guid>
        <description>属性（Attribute） 属性是提供给模块、箱或其它项目的元数据。
dead_code 用于关闭编译器对于无用代码的警告。
#[allow(dead_code)] fn unused_function() {} crate_type与crate_name 用于指定箱的类型与名称。
#![crate_type = &amp;#34;lib&amp;#34;] #![crate_name = &amp;#34;rary&amp;#34;] cfg 用于检查设置。
// 在符合条件时才编译 #[cfg(target_os = &amp;#34;linux&amp;#34;)] fn are_you_on_linux() { println!(&amp;#34;You are running linux!&amp;#34;); } // 在程序中使用宏获取设置 if cfg!(target_os = &amp;#34;linux&amp;#34;) { println!(&amp;#34;Yes. It&amp;#39;s definitely linux!&amp;#34;); } else { println!(&amp;#34;Yes. It&amp;#39;s definitely *not* linux!&amp;#34;); } 可以使用自定义属性：
#[cfg(some_condition)] fn conditional_function() { println!(&amp;#34;condition met!&amp;#34;); } 但是需要在编译时手动传入：
rustc --cfg some_condition custom.rs &amp;amp;&amp;amp; ./custom 面向对象编程（OOP）特点 怎样才算OOP语言这一点并没有明确的共识。虽然Rust的语法与普通的OOP语言相差较大，但是它仍然具有OOP的主要特点。
对象包含数据与行为：结构与枚举中包含数据，使用impl块可以为它们实现方法，因此可以将结构和枚举视为对象 封装：使用pub可以控制结构内部变量/方法的可见性 继承：继承的作用是代码复用与多态，虽然Rust本身并不提供继承机制，但是通过使用特性可以实现这两个功能 原始标识符 原始标识符允许使用关键字作为标识符。这在Rust引入新关键字，而某些旧版本代码使用了同名标识符时非常有用。</description>
      </item>
    
      <item>
        <title>进阶 - 强化学习</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/reinforcement-learning/</link>
        <pubDate>Fri, 24 Nov 2023 11:25:32 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/reinforcement-learning/</guid>
        <description>简介 与监督学习（如分类或回归）不同，强化学习是另一种重要的机器学习范式，它尝试在马尔可夫决策过程等假设下通过直接与环境互动来最大化累积奖励。此处不介绍强化学习本身的内容，只介绍Qlib中与之相关的内容。Qlib提供了一个强化学习工具箱QlibRL，它是一个针对量化投资的强化学习平台。
量化交易中的使用场景 在投资的场景中，投资者通过买卖操作来管理他们的仓位，以努力优化投资回报率。投资者在每次做出买卖决策之前，都会小心地评估市场条件与股票信息。从投资者的视角，这个过程可以看作由市场交互驱动的连续决策过程。强化学习算法为应对此类挑战提供了有前景的方法，下面是强化学习算法在量化投资领域的一些可能的应用场景：
订单执行 订单执行任务需要在考虑多种目标因素的同时高效地执行订单，这些因素包括：最优化价格、最小化交易成本、减小市场冲击、最大化订单完成率，以及在特定时间范围内完成执行。通过将这些目标结合为奖励函数与动作选择过程，就可以在此类任务上使用强化学习算法。具体来说，强化学习智能体与市场环境进行交互，观察市场当前状态，并对下一步执行做出决策。强化学习算法通过试错学习出一个最优执行策略，以达到最大化累积奖励的目的，从而实现想要的目标。
基本设定 环境：代表发生订单执行的市场，包含订货簿、流动性、价格走势与市场状况等变量 状态：表示强化学习智能体在某一时刻能够获取的信息，通常包括当前订货簿状态（买卖价差、订货簿深度）、历史价格、历史成交量、市场波动率以及其它任何可以帮助进行决策的信息 动作：指强化学习智能体基于可以观察到的状态所做出的决策。在订单执行任务中，动作包括选择订单大小、价格与执行时间 奖励：是一个表示强化学习智能体动作性能的标量信号。奖励函数被设计为鼓励那些导致高效率、低成本的订单执行的动作。它通常考虑多个目标，例如最大化价格优势、最小化交易成本（包括手续费与滑点）、减小市场冲击（订单对市场价格的影响）以及最大化订单完成率。 场景 单资产订单执行：聚焦于在单个资产上执行单个订单的任务。主要目标是在高效执行订单的同时考虑最大化价格优势、最小化交易成本、减小市场冲击以及最大化订单完成率等因素。强化学习智能体与市场环境交互并对指定资产的订单大小、价格与执行时间做出决策。目标是学习出一个能够在考虑单个资产特性的同时最大化累积奖励的最优执行策略 多资产订单执行：将订单执行任务扩展到多个资产上，需要同步地或顺序地执行跨资产的订单组合。不仅需要聚焦于执行单个订单，还要管理资产组合中不同资产间的相互作用与依赖。强化学习智能体需要对资产组合中每个资产的订单大小、价格与执行时间做出决策，同时考虑它们的相互依赖性、现金约束、市场状况及交易成本。目标是学习出一个可以平衡每个资产的执行效率，同时能将整个资产组合作为一个整体考虑其总体性能与目标的最优执行策略 资产组合构建 资产组合构建是在一个资产组合中选择与分配资产的过程。强化学习提供了一个优化资产组合管理决策的框架，它从与市场环境的互动中学习，并在考虑风险的同时最大化长期回报。
基本设定 状态：代表市场与资产组合的当前信息，通常包括历史价格与成交量、技术指标与其它相关数据 动作：对应将资金分配给不同资产的决策，决定了每个资产的投资权重或比率 奖励：评估投资组合表现的指标，可以通过不同的方式定义，如总回报率、无风险回报率，或其它目标如最大化夏普比率、最小化回撤 场景 股票市场：将强化学习用于构建股票的投资组合，智能体学习将资金分配给不同的股票 加密货币市场：将强化学习用于构建加密货币的投资组合，智能体学习资金分配决策 外汇市场：将强化学习用于构建货币对的投资组合，智能体学习基于汇率数据、经济指标和其它因素在不同货币间分配资金 例子 QlibRL提供了一个例子，实现了一个单资产订单执行任务，下面是其训练配置文件：
simulator: # Each step contains 30mins time_per_step: 30 # Upper bound of volume, should be null or a float between 0 and 1, if it is a float, represent upper bound is calculated by the percentage of the market volume vol_limit: null env: # Concurrent environment workers.</description>
      </item>
    
      <item>
        <title>进阶 - 元学习</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/meta-controller/</link>
        <pubDate>Thu, 23 Nov 2023 12:24:51 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/meta-controller/</guid>
        <description>简介 普通的机器学习算法从训练数据中学习出规律，之后用来对新的数据进行预测。元学习，意为“学习如何学习”，也是一个机器学习算法，不过它学习的目标不是某一个具体任务，而是学习任务本身。Qlib提供了元控制器模块用于进行元学习，该模块可以从一系列预测任务中学习出规律，用于指导之后的预测任务。用户可以基于元控制器模块实现自己的元模型。
元任务 元任务实例是元学习框架的基本元素，它保存有元模型能够使用的数据。多个元任务实例可以使用相同的由元数据集控制的数据处理器。用户应当使用prepare_task_data函数获取能够直接输入元模型的数据。
元数据集 元数据集控制元信息的生成过程，它负责为训练元模型提供数据。用户应当使用prepare_tasks函数获取一个元任务实例列表。
元模型 通用元模型 元模型实例是控制工作流的部分。元模型的使用方式是：
通过fit函数训练元模型 通过inference函数给出有用的信息以指导工作流 元任务模型 此类元模型可以直接与任务定义交互，它们通过修改基础任务的定义对其进行指导。可以使用prepare_tasks函数获取修改后的基础任务定义。
元指导模型 此类元模型参与基础模型的训练过程，它们通过在基础模型训练时进行指导以提高其性能。
例子 Qlib提供了元模型的一个实现：DDG-DA，它可以适应市场的变化。DDG-DA包含以下4个步骤：
计算元信息并封装进元任务实例，所有元任务构成一个元数据集实例 使用元数据集中的训练数据训练DDG-DA 推理DDG-DA以获取指导信息 在基础模型上应用指导信息以提高其性能 该例子可以在文件examples/benchmarks_dynamic/DDG-DA/workflow.py中找到。</description>
      </item>
    
      <item>
        <title>进阶 - 嵌套决策执行框架</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/nested-decision-execution/</link>
        <pubDate>Thu, 23 Nov 2023 11:34:23 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/nested-decision-execution/</guid>
        <description> 简介 日间交易（如投资组合管理）与日内交易（如订单执行）是量化投资的两个热门主题，它们通常被分开研究。为了获得二者的联合交易性能，它们必须进行交互并且一起进行回测。为了支持这种多层次联合回测策略，需要一种对应的框架，但是目前没有公开可用的高频交易框架考虑这种情况，这使得此类回测并不准确。
除了回测，不同层次策略的优化也不是独立的，而是相互影响的。例如，最好的投资组合管理策略可能随着订单执行性能的变化而变化（随着订单执行策略的改进，高换手率的投资组合可能成为更好的选择）。为了达到整体最优性能，不同层次策略之间的交互是需要考虑的。
为了解决以上问题，需要建立一个能够在多个层次上进行交易的新框架。因此，Qlib设计了一个能够考虑策略间互动的嵌套决策执行框架。
上图中黄色部分为此框架。每个层次均包含交易代理（Trading Agent）与执行环境（Execution Env）。交易代理有自己的数据处理模块（Information Extractor）、预测模块（Forecast Model）和决策生成器（Decision Generator）。交易算法基于预测模块输出的预测信号，通过决策生成器生成决策，之后决策被送至执行环境，执行环境返回执行结果。
交易算法、决策内容与执行环境的频率可以由用户自定义，并且执行环境可以与内部更细粒度的交易算法与执行环境进行嵌套（即图中的子工作流）。例如，日间交易的订单可以通过订单拆分转换为日内的更细粒度的决策。嵌套决策执行框架的灵活性使得用户可以容易地探索结合不同层次交易策略的效果，并且打破交易算法不同层次之间的优化壁垒。
例子 一个使用嵌套决策执行框架的高频交易例子在这里。
Qlib中其它有关高频交易的工作：
使用高频数据进行预测 从没有固定频率的高频数据中提取特征的例子 一篇高频交易的论文 </description>
      </item>
    
      <item>
        <title>进阶 - 在线服务</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/online-serving/</link>
        <pubDate>Thu, 23 Nov 2023 16:09:11 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/online-serving/</guid>
        <description>简介 一般情况下，Qlib使用静态的配置文件或代码定义模型、数据集与训练任务，如果它们有任何改变，则需要修改配置文件或代码并重新运行任务。但是频繁地进行此操作过于繁琐，为此，Qlib提出了在线服务功能，通过事先定义配置文件模板，此功能可以自动更新配置文件并重新运行任务。其架构图如下：
这里有一些可供参考的例子，它们展示了在线服务的不同特性。
在线管理器 在线管理器可以管理一组在线策略并动态地运行它们。
随着时间变化，模型也会变化。在本模块中，这些模型被称为在线模型。在每个例行程序（如每天或每分钟）中，在线模型可能有变化，因此它们的预测也需要更新，所以本模块提供一系列方法来控制这个过程。本模块也提供一个方法以在历史上仿真在线策略，这意味着可以验证策略或找到一个更好的策略。
在不同的情况下使用不同的训练器的组合一共有4种：
在线+训练器：当想要运行真实例行程序时，训练器会帮助逐任务逐策略地训练模型 在线+延迟训练器：在所有策略都准备好任务后，延迟训练器才会开始训练，这使用户可以在routine或first_train结束后并行地训练所有任务；在策略准备好任务前，这些函数会阻塞 仿真+训练器：与第一种组合表现相同，唯一区别是本组合用于仿真/回测而不是在线交易 仿真+延迟训练器：在模型没有时间依赖时，可以使用延迟训练器的多任务能力。这意味着在仿真结束时，所有例行程序中的所有任务都会被真正地训练。根据是否有新模型在线，信号会在不同的时间段准备好 下面是演示每种情况工作流的伪代码。其中做了以下简化：
只使用了一个策略 update_online_pred只有在在线模式才会被调用 在线+训练器：
tasks = first_train() models = trainer.train(tasks) trainer.end_train(models) for day in online_trading_days: # OnlineManager.routine models = trainer.train(strategy.prepare_tasks()) # 对于每个策略 strategy.prepare_online_models(models) # 对于每个策略 trainer.end_train(models) prepare_signals() # 每天准备交易信号 在线+延迟训练器：与在线+训练器的工作流相同
仿真+延迟训练器：
# 仿真 tasks = first_train() models = trainer.train(tasks) for day in historical_calendars: # OnlineManager.routine models = trainer.train(strategy.prepare_tasks()) # 对于每个策略 strategy.prepare_online_models(models) # 对于每个策略 # delay_prepare() # FIXME: 目前delay_prepare没有用合适的方式实现 trainer.</description>
      </item>
    
      <item>
        <title>进阶 - 任务管理</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/task-management/</link>
        <pubDate>Mon, 27 Nov 2023 10:16:24 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/task-management/</guid>
        <description>简介 工作流部分介绍了如何以低耦合的方式运行研究工作流，但是使用qrun时只能执行一个任务。为了自动生成与执行不同的任务，任务管理模块提供了一整套流程，包括任务生成、任务储存、任务训练与任务收集。使用此模块，用户可以在不同周期下，使用不同的损失甚至不同的模型运行任务。任务生成、模型训练以及数据合并与收集的流程如下：
该流程的一个例子在这里。该流程可以用于在线服务。
任务生成 一个任务包括模型、数据集、记录以及任何用户添加的内容。即使任务模板是固定的，用户仍然可以通过自定义TaskGen类来生成不同的任务。Qlib提供了RollingGen类来生成一系列使用不同时间段数据集的任务，这允许用户在一个实验中验证不同时间段数据在模型上的效果。
任务储存 为了达到更高的效率，并获得集群操作的可能性，任务管理器将所有任务保存在MongoDB中。任务管理器可以自动获取未完成的任务并通过错误处理来管理一组任务的生命周期。用户在使用本模块时必须完成MongoDB的配置，可以在初始化时提供MongoDB的URL和数据库名，或在代码中做如下声明：
from qlib.config import C C[&amp;#34;mongo&amp;#34;] = { &amp;#34;task_url&amp;#34; : &amp;#34;mongodb://localhost:27017/&amp;#34;, # MongoDB的url &amp;#34;task_db_name&amp;#34; : &amp;#34;rolling_db&amp;#34; # 数据库名 } 任务训练 在生成与储存任务后，就需要运行处于等待状态的任务。Qlib提供了run_task方法来运行任务池中的任务，但是用户也可以自定义如何执行任务。获取task_func的一个简单的方法是使用直接qlib.model.trainer.task_train方法，它将运行被任务定义的包括了模型、数据集、记录的整个工作流。
训练器训练一组任务并返回一组模型记录器。Qlib提供了两种训练器，TrainerR是最简单的方式；TrainerRM基于任务管理器，可以帮助自动管理任务的生命周期。如果不需要使用任务管理器，则使用TrainerR训练一组TaskGen生成的任务就足够了。
任务收集 在收集模型的训练结果前，需要使用qlib.init指出mlrun的路径。
为了在训练后收集任务的结果，Qlib提供了Collector、Group和Ensemble，它们分别以只读、可扩展和松耦合的方式收集结果。
Collector可以从任何地方收集对象，并对它们进行处理，如合并、分组、平均等。它有两步操作：collect（将所有信息收集到一个字典中）与process_collect（处理收集的字典）。
Group同样有两个步骤：group（基于group_func将一些对象分组并将它们转换为字典）与reduce（基于某些规则将字典转换为一个整体）。
Ensemble可以将多个对象合并为一个整体。可以在Collector的处理列表中设置想要的整合方法。常用的整合方法包括AverageEnsemble与RollingEnsemble。AverageEnsemble用于将同一时间段不同模型的结果合并；RollingEnsemble用于将不同时间段相同模型的结果合并。
所以以上三种方法的层次是：Collector的第二个步骤对应Group，而Group的第二个步骤对应Ensemble。</description>
      </item>
    
      <item>
        <title>其他特性</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/other-features/</link>
        <pubDate>Sat, 10 Jun 2023 15:17:07 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/other-features/</guid>
        <description>nullptr C++11以前通常用NULL表示空指针，但是NULL是用#define定义的，通常定义为0：
#define NULL 0 因此实际上它与数值0没有区别，这在重载时会引发混乱。如果定义以下两个重载函数：
void foo(char *); void foo(int); 在用NULL作为参数调用时：
foo(NULL); 用户应该希望调用char*版本，然而由于NULL实际上是0，会导致调用int版本。为了解决这一问题，C++11引入了nullptr关键字用来专门表示空指针。它是std::nullptr_t类型的纯右值，可以隐式转换为任何指针类型及任何成员指针类型。使用nullptr调用上述函数：
foo(nullptr); 可以正确调用char*版本。
基于范围的for循环 C++11引入了基于范围的for循环，它相当于其它语言的for-each或for-in循环，可以使循环代码更加简洁。
std::vector&amp;lt;int&amp;gt; arr(5, 100); for (auto &amp;amp;i : arr) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } 条件表达式中支持初始化语句 c++17中支持在if或者switch语句中进行初始化，这个能力的出现能够让代码更加简洁。
std::map&amp;lt;int, std::string&amp;gt; c = {{1, &amp;#34;a&amp;#34;}}; if (auto res = c.insert(std::make_pair(2, &amp;#34;b&amp;#34;)); !res.second) { std::cout &amp;lt;&amp;lt; &amp;#34;key 1 exist&amp;#34; &amp;lt;&amp;lt; std::endl; } else { std::cout &amp;lt;&amp;lt; &amp;#34;insert success, value:&amp;#34; &amp;lt;&amp;lt; res.first-&amp;gt;second &amp;lt;&amp;lt; std::endl; } 非成员函数std::begin()与std::end() C++标准库中的容器都实现了begin()与end()成员函数，用于获取首尾迭代器。例如：</description>
      </item>
    
      <item>
        <title>其它 - 建立公式化alpha</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/formulaic-alpha/</link>
        <pubDate>Mon, 27 Nov 2023 10:11:03 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/formulaic-alpha/</guid>
        <description>简介 在量化交易实践中，设计能够解释并预测未来资产回报率的新因子对于策略的盈利能力是至关重要的。这些因子通常称为alpha因子或简称为alpha。公式化alpha，顾名思义，是指能够表示为公式或数学表达式的alpha。
例子 在Qlib中，用户可以方便地建立公式化alpha。例如，用户可以使用数据处理器建立MACD这一常用公式化alpha：
&amp;gt;&amp;gt; from qlib.data.dataset.loader import QlibDataLoader &amp;gt;&amp;gt; MACD_EXP = &amp;#39;(EMA($close, 12) - EMA($close, 26))/$close - EMA((EMA($close, 12) - EMA($close, 26))/$close, 9)/$close&amp;#39; &amp;gt;&amp;gt; fields = [MACD_EXP] # MACD &amp;gt;&amp;gt; names = [&amp;#39;MACD&amp;#39;] &amp;gt;&amp;gt; labels = [&amp;#39;Ref($close, -2)/Ref($close, -1) - 1&amp;#39;] # 标签 &amp;gt;&amp;gt; label_names = [&amp;#39;LABEL&amp;#39;] &amp;gt;&amp;gt; data_loader_config = { .. &amp;#34;feature&amp;#34;: (fields, names), .. &amp;#34;label&amp;#34;: (labels, label_names) .. } &amp;gt;&amp;gt; data_loader = QlibDataLoader(config=data_loader_config) &amp;gt;&amp;gt; df = data_loader.</description>
      </item>
    
      <item>
        <title>其它 - 序列化</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/serialization/</link>
        <pubDate>Mon, 27 Nov 2023 10:13:37 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/serialization/</guid>
        <description> 简介 Qlib支持将DataHandler、DataSet、Processor、Model等对象的状态转存至硬盘以及重新载入它们。
序列化类 Qlib提供了基类Serializable，它的状态可以以pickle格式转存至硬盘或从硬盘载入。当转存一个Serializable类的实例时，该实例的所有不以下划线开头的属性将被保存至硬盘。然而，用户可以通过使用config方法或覆盖default_dump_all属性阻止这一特性。
用户也可以覆盖pickle_backend属性以选择pickle后端，支持的值有pickle（默认、常用）与dill（转存更多东西，比如函数）。
例子 可以使用如下代码序列化DatasetH：
##=============转存数据集============= dataset.to_pickle(path=&amp;#34;dataset.pkl&amp;#34;) # dataset是qlib.data.dataset.DatasetH类的实例 ##=============载入数据集============= with open(&amp;#34;dataset.pkl&amp;#34;, &amp;#34;rb&amp;#34;) as file_dataset: dataset = pickle.load(file_dataset) </description>
      </item>
    
      <item>
        <title>其它 - 时间点数据库</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/pit-database/</link>
        <pubDate>Mon, 27 Nov 2023 10:17:22 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/pit-database/</guid>
        <description>简介 在进行任何类型的历史市场分析时，时间点数据都是非常重要的。假设我们使用过去5年的历史数据对一个交易策略进行回测，模型每天在市场收盘时交易一次，如果我们正在为2020年1月1日计算交易信号，则在这个时间点，我们应该只有这一天及之前的数据。
在金融数据（尤其是金融报表）中，同一数据可能随着时间被修改过多次。如果我们只使用最新版本的数据做历史回测，则会产生数据泄漏。时间点数据库用于解决此问题，以保证用户在任何历史时间点上都能得到正确版本的数据，这可以使在线交易与历史回测的性能保持相同。
数据准备 首先需要使用Qlib提供的爬虫下载金融数据，并使用转换脚本将其转换为Qlib格式。
基于文件设计的时间点数据 Qlib为时间点数据提供了一个基于文件的存储。
特征数据保存在文件XXXX.data中，其中每行是一个特征在一个时间点的记录，每行有以下4列：
data：该行数据的发布日期 period：特征的周期（在多数市场里为季度） 如果周期为年，则为对应的整数 如果周期为季度，则为形如&amp;lt;year&amp;gt;&amp;lt;index of quarter&amp;gt;的整数 value：存储的数值 _next：同一特征下一次出现的位置索引 该文件中的数据按照data字段升序排列。
除了特征数据外，还有一个索引文件XXXX.index，用于加快查询的速度。该文件中保存了每个特征第一次出现的索引，如果一个特征出现了多次，可以通过XXXX.data文件中的_next字段逐个访问。
# XXXX.data文件的数据格式 array([(20070428, 200701, 0.090219 , 4294967295), (20070817, 200702, 0.13933 , 4294967295), (20071023, 200703, 0.24586301, 4294967295), (20080301, 200704, 0.3479 , 80), (20080313, 200704, 0.395989 , 4294967295), (20080422, 200801, 0.100724 , 4294967295), (20080828, 200802, 0.24996801, 4294967295), (20081027, 200803, 0.33412001, 4294967295), (20090325, 200804, 0.39011699, 4294967295), (20090421, 200901, 0.102675 , 4294967295), (20090807, 200902, 0.230712 , 4294967295), (20091024, 200903, 0.</description>
      </item>
    
      <item>
        <title>其它 - 在线模式与离线模式</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/online-offline-mode/</link>
        <pubDate>Mon, 27 Nov 2023 10:18:01 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/online-offline-mode/</guid>
        <description>简介 Qlib支持在线模式与离线模式，前面只介绍了离线模式。在线模式被设计用于解决以下问题：
使用中心化的方式管理数据，使用户无需管理不同版本的数据 减少生成的缓存数量 使数据可以远程访问 Qlib-Server Qlib-Server是Qlib的服务器系统，它利用Qlib做基础计算，并提供了服务器系统与缓存机制。Qlib-Server让用户可以以在线模式使用Qlib。</description>
      </item>
    
      <item>
        <title>使用nvJPEG加速解码JPG图像</title>
        <link>https://zqwang-cn.github.io/posts/use-nvjpeg-to-accelerate-jpg-image-decoding/</link>
        <pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/use-nvjpeg-to-accelerate-jpg-image-decoding/</guid>
        <description>背景 在读取JPG图像时，需要先对图像进行解码。一般的图像库（如opencv）采用CPU进行解码，如果对速度有很高要求则需要另外实现。
nvJPEG是英伟达提供的可以使用GPU加速的JPG解码库，它包含在较高版本的CUDA（&amp;gt;10.0）中，如果使用低版本CUDA，则需要另外安装。
步骤 1. 假设待解码的本地文件为test.jpg，首先将其二进制数据读入内存
// 以二进制方式打开文件 std::ifstream in_fs(&amp;#34;test.jpg&amp;#34;, std::ifstream::binary); // 获取文件大小 in_fs.seekg(0, std::ios::end); auto in_size = in_fs.tellg(); // 读入全部数据（使用vector避免手动申请/释放空间） std::vector&amp;lt;uchar&amp;gt; in_buf(in_size); in_fs.seekg(0); in_fs.read((char*)in_buf.data(), in_size); 2. 初始化nvJPEG，建立handle与state
nvjpegHandle_t handle; nvjpegJpegState_t state; nvjpegCreateSimple(&amp;amp;handle); nvjpegJpegStateCreate(handle, &amp;amp;state); 3. 获取图像长宽、通道数、subsampling等信息
int widths[NVJPEG_MAX_COMPONENT]; int heights[NVJPEG_MAX_COMPONENT]; int channels; nvjpegChromaSubsampling_t subsampling; nvjpegGetImageInfo(handle, in_buf.data(), in_size, &amp;amp;channels, &amp;amp;subsampling, widths, heights); 4. 设置输出参数并解码
解码时，除了需要传入输入数据及大小外，还需要指定输出格式（nvjpegOutputFormat_t）及输出图像信息（nvjpegImage_t，包含每个通道的行宽度pitch，以及每个通道的输出缓存地址channel）
此处指定输出格式为NVJPEG_OUTPUT_BGRI，该格式将所有输出写入channel[0]中，格式为&amp;quot;BGRBGRBGR&amp;hellip;&amp;quot;，因此picth[0]为图像宽度×3，channel[0]缓存大小至少应为图像长度×图像宽度×3。如果需要使用其它格式请参考官方文档
// 计算输出行宽度与总大小 int mul = 3; int out_step = widths[0] * mul; int out_size = out_step * heights[0]; // 设置输出信息，并在显存上申请缓存 nvjpegImage_t out_buf; out_buf.</description>
      </item>
    
      <item>
        <title>cv::Mat通道顺序转换（HWC转CHW）</title>
        <link>https://zqwang-cn.github.io/posts/cv-mat-channel-transpose-hwc-to-chw/</link>
        <pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/cv-mat-channel-transpose-hwc-to-chw/</guid>
        <description> 简介 在深度学习的图像前处理中，一般会将HWC格式的图像转换为CHW格式，因此需要进行通道顺序转换操作。不同的框架提供了不同的操作：
在python版OpenCV中，使用numpy.transpose（OpenCV本身不支持） 在pytorch中，使用torch.permute 在tensorflow中，使用tf.transpose C++版OpenCV中进行HWC转CHW C++版本OpenCV不提供通道转换操作，可以使用以下方法进行HWC转CHW（不支持任意转换操作）：
// 原始图像，尺寸为(h, w, c) cv::Mat image; int h = image.rows; int w = image.cols; int c = image.channels(); // 尺寸转换为(h*w, c, 1)，此步骤不对内存进行修改 image = image.reshape(1, h * w); // 图像转置，尺寸变为(c, h*w, 1) image = image.t(); // 尺寸转换为(c, h, w)，此步骤不对内存进行修改 image = image.reshape(w, c); </description>
      </item>
    
      <item>
        <title>在Linux中使用微信/企业微信</title>
        <link>https://zqwang-cn.github.io/posts/use-wechat-wework-in-linux/</link>
        <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/use-wechat-wework-in-linux/</guid>
        <description>简介 通过Wine运行Windows程序 使用Docker避免复杂的Wine配置 微信 1. 首次运行
sudo docker run -d --name wechat --device /dev/snd --ipc=&amp;#34;host&amp;#34; \ -v /tmp/.X11-unix:/tmp/.X11-unix \ -v $HOME/WeChatFiles:/WeChatFiles \ -e DISPLAY=unix$DISPLAY \ -e XMODIFIERS=@im=fcitx \ -e QT_IM_MODULE=fcitx \ -e GTK_IM_MODULE=fcitx \ -e AUDIO_GID=`getent group audio | cut -d: -f3` \ -e GID=`id -g` \ -e UID=`id -u` \ bestwu/wechat 2. 停止
sudo docker stop wechat 3. 再次运行
sudo docker start wechat 企业微信 1. 首次运行
sudo docker run -d --name wework --device /dev/snd --ipc host \ -v /tmp/.</description>
      </item>
    
      <item>
        <title>使用iptables控制仅限指定IP访问指定端口</title>
        <link>https://zqwang-cn.github.io/posts/use-iptables-to-control-port-access/</link>
        <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/use-iptables-to-control-port-access/</guid>
        <description>背景 在服务器上，如果将某个端口开放使所有IP都可以访问，则可能会引起攻击或增加不必要的流量。此时可以使用iptables控制仅使需要的IP可以访问。
步骤 1. 首先禁止所有IP访问端口：
iptables -I INPUT -p tcp --dport {port} -j DROP 2. 之后将该端口开放给指定IP：
iptables -I INPUT -s {ip} -p tcp --dport {port} -j ACCEPT 其中ip可以为单一IP（如192.168.1.1），也可以为带掩码的一组IP（如192.168.1.0/24）。
3. 导入/导出规则
# 导出 iptables-save &amp;gt; {file} # 导入 iptables-restore &amp;lt; {file} 4. 重启后自动导入规则
无论直接添加的规则还是导入的规则，在重启后都不会保存，需要重新添加或导入。因此需要在/etc/rc.local中使用iptables-restore自动导入规则。
5. 使用脚本自动添加当前ssh登录ip
ip=`who | grep -o &amp;#34;[0-9]*\.[0-9]*\.[0-9]*\.&amp;#34; | tail -n 1`&amp;#34;0/24&amp;#34; port=12345 echo $ip:$port iptables -C INPUT -s $ip -p tcp --dport $port -j ACCEPT if [ $?</description>
      </item>
    
      <item>
        <title>编译OpenCV以支持CUDA功能</title>
        <link>https://zqwang-cn.github.io/posts/compile-opencv-to-support-cuda/</link>
        <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/compile-opencv-to-support-cuda/</guid>
        <description> 背景 在Linux系统中，使用apt等包管理软件安装的OpenCV默认不支持CUDA，如需使用则要自行编译。
步骤 1. 从OpenCV官网下载源码，将其内容解压至opencv-{version}/。
2. 从github下载OpenCV contrib包，将其解压至opencv-{version}/opencv_contrib-{version}/。注意两个包的版本要相同。
3. 在opencv-{version}/下建立build文件夹，执行以下命令：
cd opencv-{version}/build cmake -DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib-{version}/modules -DWITH_CUDA=1 .. make -j8 install 说明 在执行cmake命令时，如需其它功能，可以自行添加其它编译变量 在编译前可能需要使用apt等安装依赖 </description>
      </item>
    
      <item>
        <title>BGSLibrary背景提取库介绍</title>
        <link>https://zqwang-cn.github.io/posts/bgslibrary-introduction/</link>
        <pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/bgslibrary-introduction/</guid>
        <description>简介 BGSLibrary(Background Subtraction Library) 是一个背景减除（背景提取）库，它使用C++开发，提供Python/Matlab/Java接口，并可以跨平台使用(Windows/Ubuntu/OS X)。
安装 可以编译安装，也可以安装二进制包。但是对于python可以直接使用pip安装，非常方便：
pip install pybgs 使用 根据官方demo，使用方法十分简单（以python为例）：
import numpy as np import cv2 import pybgs as bgs algorithm = bgs.FrameDifference() video_file = &amp;#34;dataset/video.avi&amp;#34; capture = cv2.VideoCapture(video_file) while True: flag, frame = capture.read() if not flag: break img_output = algorithm.apply(frame) img_bgmodel = algorithm.getBackgroundModel() cv2.imshow(&amp;#39;video&amp;#39;, frame) cv2.imshow(&amp;#39;img_output&amp;#39;, img_output) cv2.imshow(&amp;#39;img_bgmodel&amp;#39;, img_bgmodel) if cv2.waitKey(10) == 27: break 所有算法具有相同接口，如需更换算法只需修改algorithm变量即可。
支持的算法 支持算法列表</description>
      </item>
    
      <item>
        <title>c&#43;&#43;统一函数接口返回不同类型的值</title>
        <link>https://zqwang-cn.github.io/posts/c-plusplus-unified-function-interface-return-different-types-of-value/</link>
        <pubDate>Thu, 15 Oct 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/c-plusplus-unified-function-interface-return-different-types-of-value/</guid>
        <description>假设存在以下函数：
int get_int(); float get_float(); std::string get_string(); 想要将其整合为一个函数get_value()，根据需要返回不同类型的数据。
尝试使用函数模板，在函数中根据数据类型执行不同的操作：
template &amp;lt;typename T&amp;gt; T get_value() { T ret; if (std::is_same&amp;lt;T, int&amp;gt;::value) ret = get_int(); else if (std::is_same&amp;lt;T, float&amp;gt;::value) ret = get_float(); else if (std::is_same&amp;lt;T, std::string&amp;gt;::value) ret = get_string(); return ret; } 然而这样会出现编译错误。这是由于在实际使用时，编译器会根据T的实际类型将模板实例化为一个普通函数，例如当T为int时，实例化的函数为：
int get_value() { int ret; if (std::is_same&amp;lt;int, int&amp;gt;::value) ret = get_int(); else if (std::is_same&amp;lt;int, float&amp;gt;::value) ret = get_float(); else if (std::is_same&amp;lt;int, std::string&amp;gt;::value) ret = get_string(); return ret; } 此时两个else if语句中的代码虽然永远不会执行，但是它们却不能通过编译。因此此方法无效。</description>
      </item>
    
      <item>
        <title>Anchor free检测算法概述</title>
        <link>https://zqwang-cn.github.io/posts/anchor-free-detection-algorithms-overview/</link>
        <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/anchor-free-detection-algorithms-overview/</guid>
        <description>0. Anchor based v.s. anchor free Anchor based算法 什么是anchor： 在图像中预先设置的不同大小与尺度的候选框，覆盖几乎所有位置与尺度，用于对每个位置是否存在物体进行判断。
基本步骤：Anchor based算法通常分为2步：
对每个anchor内的图像进行分类，以确定物体类型与其置信度 对置信度高的anchor边界在小范围内进行回归，以确定准确边界 Anchor free算法 顾名思义，即不使用anchor的检测算法。通常使用类似分割或关键点检测的方式直接对每个点进行处理。大致可分为2类：
密集预测（置信度与偏移量）的方法 基于关键点匹配的方法 1. 密集预测的方法 1.0 基本结构 1.1 DenseBox Huang L, Yang Y, Deng Y, et al. Densebox: Unifying landmark localization with end to end object detection[J]. arXiv preprint arXiv:1509.04874, 2015.
结构 class分支为人脸中心一个圆形区域的heatmap box分支为到边界的距离 class分支与box分支均采用L2 loss 设计用于人脸检测，类别数量C=1 特点 将图像裁剪为patch分别进行处理 使用类似编码器/解码器的结构进行多尺度特征融合 使用hard negative mining解决正负样本不平衡的问题 可以使用landmark增强效果 评价 最早的anchor free检测算法之一，最新的同类算法仍然采用大致相同的思路，只是在细节进行改进。 1.2 UnitBox Yu J, Jiang Y, Wang Z, et al.</description>
      </item>
    
      <item>
        <title>c语言&#43;&#43;操作符与函数调用的问题</title>
        <link>https://zqwang-cn.github.io/posts/c-plusplus-operator-and-function-call-problem/</link>
        <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/c-plusplus-operator-and-function-call-problem/</guid>
        <description>假设有如下c函数：
void func(int a, int b, int c) { printf(&amp;#34;%d,%d,%d\n&amp;#34;,a,b,c); } 使用如下方式调用：
int i=0; func(i++, i++, i++); 希望的输出是：
0,1,2 但是实际输出是：
2,1,0 分析原因，应该是由于c语言的参数压栈顺序为从右向左，因此实际执行的过程是：
int i = 0; int c = i; i = i + 1; int b = i; i = i + 1; int a = i; i = i + 1; func(a, b, c); 但是如果使用如下方式调用：
int i=0; func(++i, ++i, ++i); 输出却是：
3,3,3 其原因猜测是因为，与i++不同，++i操作没有生成临时变量，因此最后使用的是同一个i。其执行过程如下：
int i = 0; i = i + 1; i = i + 1; i = i + 1; func(i, i, i); 为了验证以上猜想，考虑如下调用：</description>
      </item>
    
      <item>
        <title>架设RTMP流媒体服务器并使用python进行推流</title>
        <link>https://zqwang-cn.github.io/posts/install-rtmp-server-and-push-stream-using-python/</link>
        <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/install-rtmp-server-and-push-stream-using-python/</guid>
        <description>1、服务器架设 服务器不一定要安装在推流程序所在的机器上，也可以安装在发送、接收双方均可访问到的第三台机器上。
安装方式可以使用docker镜像或直接编译安装。
使用docker镜像 github地址：https://github.com/alfg/docker-nginx-rtmp
安装并运行：
docker pull alfg/nginx-rtmp docker run -it -p 1935:1935 -p 8080:80 --rm alfg/nginx-rtmp 之后即可推流至：
rtmp://&amp;lt;server ip&amp;gt;:1935/stream/$STREAM_NAME 自行编译安装 # 安装依赖库 sudo apt install -y libpcre3 libpcre3-dev openssl libssl-dev zlib1g-dev # 下载nginx源码并解压 wget http://nginx.org/download/nginx-1.17.8.tar.gz tar -xf nginx-1.17.8.tar.gz # 下载nginx-rtmp-module模块源码 git clone https://github.com/arut/nginx-rtmp-module.git # 编译并安装带nginx-rtmp-module模块的nginx cd nginx-1.17.8 ./configure --add-module=../nginx-rtmp-module sudo make install 配置nginx，配置文件地址为：/usr/local/nginx/conf/nginx.conf。由于目前浏览器已经禁止使用Flash，不能直接播放rtmp流，因此可以选择添加hls配置。
worker_processes 1; events { worker_connections 1024; } rtmp { server { listen 1935; chunk_size 4096; application stream { live on; record off; # hls配置 hls on; hls_path /var/www/hls; hls_fragment 3; hls_playlist_length 60; } } } http { server { listen 80; # hls配置 location /hls { # Disable cache add_header Cache-Control no-cache; # CORS setup add_header &amp;#39;Access-Control-Allow-Origin&amp;#39; &amp;#39;*&amp;#39; always; add_header &amp;#39;Access-Control-Expose-Headers&amp;#39; &amp;#39;Content-Length&amp;#39;; # allow CORS preflight requests if ($request_method = &amp;#39;OPTIONS&amp;#39;) { add_header &amp;#39;Access-Control-Allow-Origin&amp;#39; &amp;#39;*&amp;#39;; add_header &amp;#39;Access-Control-Max-Age&amp;#39; 1728000; add_header &amp;#39;Content-Type&amp;#39; &amp;#39;text/plain charset=UTF-8&amp;#39;; add_header &amp;#39;Content-Length&amp;#39; 0; return 204; } types { application/vnd.</description>
      </item>
    
  </channel>
</rss>