<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wang&#39;s blog</title>
    <link>https://zqwang-cn.github.io/cpp-new-features/</link>
    <description>Wang&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2023, zqwang; All rights reserved.</copyright>
    <lastBuildDate>Tue, 30 May 2023 21:27:12 +0800</lastBuildDate><atom:link href="https://zqwang-cn.github.io/cpp-new-features/index.xml" rel="self" type="application/rss+xml" />
      <item>
        <title>智能指针</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/smart-pointers/</link>
        <pubDate>Tue, 30 May 2023 21:27:12 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/smart-pointers/</guid>
        <description>C++11标准废弃了原来的智能指针auto_ptr，同时引入了三个新的智能指针：unique_ptr, shared_ptr与weak_ptr。它们基于RAII原则进行内存管理。
RAII（资源获取即初始化） C++中可以在栈上或堆上申请内存，栈上申请的内存会在超出作用域时自动释放，但是堆上申请的内存需要手动释放，否则会出现内存泄漏。在现代C++中，通常基于RAII原则编写代码，以避免出现内存泄漏。
RAII的基本原则是：尽可能在栈上申请资源，如果由于资源太大或其它原因必须在堆上申请时，则该资源需要由一个栈上的对象持有；在该对象初始化时即获取该资源，同时在该对象的析构函数中释放该资源。在超出持有资源对象的作用域时，其析构函数会被自动调用，进而释放所持有的资源，从而避免了内存泄漏。
unique_ptr 特点 unique_ptr对象持有一个底层指针，在unique_ptr对象析构时会自动释放该指针。通过禁用拷贝构造函数与拷贝赋值操作符，unique_ptr保证此底层指针只有一个持有者。如需转移底层指针的所有权，可以使用移动语义，移动后原unique_ptr失效。
在确定同时只能有一个所有者的情况下，使用unique_ptr可以在编译期间即保证此约束，从而避免运行期间出现错误，同时可以简化代码逻辑并提高运行效率。
实现 在unique_ptr类中，至少需要实现以下功能：
普通构造函数：保存传入的指针 析构函数：释放持有的指针 拷贝构造函数/赋值操作符：禁止使用，避免多个持有者 移动构造函数/赋值操作符：实现底层指针所有权的转移 *与-&amp;gt;操作符：实现与普通指针相同的操作 一个简单的实现如下：
template &amp;lt;typename T&amp;gt; class unique_ptr { public: // 普通构造函数，保存传入的指针 unique_ptr(T *p = nullptr) : ptr_(p) {} // 析构函数 ~unique_ptr() { // 底层指针非空则释放 if (ptr_) { delete ptr_; ptr_ = nullptr; } } // 禁用拷贝构造函数与赋值操作符，保证只有一个所有者 unique_ptr(const unique_ptr &amp;amp;) = delete; unique_ptr &amp;amp;operator=(const unique_ptr &amp;amp;) = delete; // 移动构造函数 unique_ptr(unique_ptr &amp;amp;&amp;amp;p) { // 保存底层指针 ptr_ = p.</description>
      </item>
    
  </channel>
</rss>