<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wang&#39;s blog</title>
    <link>https://zqwang-cn.github.io/</link>
    <description>Wang&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2023, zqwang; All rights reserved.</copyright>
    <lastBuildDate>Thu, 23 Nov 2023 16:01:57 +0800</lastBuildDate><atom:link href="https://zqwang-cn.github.io/index.xml" rel="self" type="application/rss+xml" />
      <item>
        <title>智能指针</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/smart-pointers/</link>
        <pubDate>Tue, 30 May 2023 21:27:12 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/smart-pointers/</guid>
        <description>C++11标准废弃了原来的智能指针auto_ptr，同时引入了三个新的智能指针：unique_ptr, shared_ptr与weak_ptr。它们基于RAII原则进行内存管理。
RAII（资源获取即初始化） C++中可以在栈上或堆上申请内存，栈上申请的内存会在超出作用域时自动释放，但是堆上申请的内存需要手动释放，否则会出现内存泄漏。在现代C++中，通常基于RAII原则编写代码，以避免出现内存泄漏。
RAII的基本原则是：尽可能在栈上申请资源，如果由于资源太大或其它原因必须在堆上申请时，则该资源需要由一个栈上的对象持有；在该对象初始化时即获取该资源，同时在该对象的析构函数中释放该资源。在超出持有资源对象的作用域时，其析构函数会被自动调用，进而释放所持有的资源，从而避免了内存泄漏。
unique_ptr 特点 unique_ptr对象持有一个底层指针，在unique_ptr对象析构时会自动释放该指针。通过禁用拷贝构造函数与拷贝赋值操作符，unique_ptr保证此底层指针只有一个持有者。如需转移底层指针的所有权，可以使用移动语义，移动后原unique_ptr失效。
在确定同时只能有一个所有者的情况下，使用unique_ptr可以在编译期间即保证此约束，从而避免运行期间出现错误，同时可以简化代码逻辑并提高运行效率。
实现 在unique_ptr类中，至少需要实现以下功能：
普通构造函数：保存传入的指针 析构函数：释放持有的指针 拷贝构造函数/赋值操作符：禁止使用，避免多个持有者 移动构造函数/赋值操作符：实现底层指针所有权的转移 *与-&amp;gt;操作符：实现与普通指针相同的操作 一个简单的实现如下：
template &amp;lt;typename T&amp;gt; class unique_ptr { public: // 普通构造函数，保存传入的指针 unique_ptr(T *p = nullptr) : ptr_(p) {} // 析构函数 ~unique_ptr() { // 底层指针非空则释放 if (ptr_) { delete ptr_; ptr_ = nullptr; } } // 禁用拷贝构造函数与赋值操作符，保证只有一个所有者 unique_ptr(const unique_ptr &amp;amp;) = delete; unique_ptr &amp;amp;operator=(const unique_ptr &amp;amp;) = delete; // 移动构造函数 unique_ptr(unique_ptr &amp;amp;&amp;amp;p) { // 保存底层指针 ptr_ = p.</description>
      </item>
    
      <item>
        <title>一、变量与常量</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/variables-and-constants/</link>
        <pubDate>Thu, 16 Mar 2023 23:37:05 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/variables-and-constants/</guid>
        <description>变量 变量绑定 使用let语句将字面值或另一变量绑定至一个变量。Rust是静态类型语言，每个变量的类型在编译期就已经确定，变量类型可以手动指定也可由编译器推断。
// 将字面值绑定至变量 let an_integer = 1u32; // 将另一变量绑定至此变量 let copied_integer = an_integer; 可变性 基本上所有的语言中，变量默认都是可变的。但是在Rust中，为了达到最大的安全性，变量默认为不可变的，如需使用可变变量，需要使用mut显示声明。
// 声明不可变变量 let immutable_binding = 1; // 错误，不可修改不可变变量 immutable_binding += 1 // 声明可变变量 let mut mutable_binding = 1; // 修改可变变量 mutable_binding += 1; 作用域 每个变量有其作用域，它被限制为只在其所在代码块中有效。
fn main() { // 此变量在整个main函数内有效 let long_lived_binding = 1; // 此代码块的作用域小于main函数 { // 此变量只在当前代码块中有效 let short_lived_binding = 2; // 正确 println!(&amp;#34;inner short: {}&amp;#34;, short_lived_binding); } // 代码块结束 // 错误，超出作用域，无法使用此变量 println!</description>
      </item>
    
      <item>
        <title>简介</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/introduction/</link>
        <pubDate>Tue, 07 Mar 2023 21:42:20 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/introduction/</guid>
        <description> 简介 Qlib是一个面向人工智能的量化研究平台，主要用于进行基于人工智能(机器学习/深度学习/强化学习)算法的量化策略的研究。
使用Qlib，用户可以简单地测试他们的想法并建立更好的量化投资策略。
框架 Qlib是一个由以上模块构成的平台。这些模块被设计为松耦合，每个模块可以单独使用。
框架主要分为4层：
基础设施层：提供量化研究的底层支持 学习框架层：用于训练可训练模型，支持监督学习与强化学习两类 工作流层：覆盖量化研究的整个工作流 接口层：为用户提供友好的接口 </description>
      </item>
    
      <item>
        <title>快速开始</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/quickstart/</link>
        <pubDate>Tue, 21 Nov 2023 15:19:34 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/quickstart/</guid>
        <description>安装 使用pip安装最新的稳定版本： pip install pyqlib 如需使用最新的开发版本，可以从源码安装： # 安装依赖 pip install numpy pip install --upgrade cython # 下载源码并安装 git clone https://github.com/microsoft/qlib.git &amp;amp;&amp;amp; cd qlib pip install . 数据准备 Qlib提供了一个获取股票数据的脚本。该数据是通过爬虫从雅虎财经网站上获取的，质量较低。如需使用高质量数据，需要用户自行准备。
通过python模块获取数据 # 获取日线数据 python -m qlib.run.get_data qlib_data --target_dir ~/.qlib/qlib_data/cn_data --region cn # 获取分钟线数据 python -m qlib.run.get_data qlib_data --target_dir ~/.qlib/qlib_data/cn_data_1min --region cn --interval 1min 通过代码获取数据 # 获取日线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/cn_data --region cn # 获取分钟线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/cn_data_1min --region cn --interval 1min 自动量化研究工作流 Qlib提供了一个工具程序qrun，可以根据配置文件自动运行整个工作流（包括建立数据集、训练模型、回测与评估），并得到图形报表分析。</description>
      </item>
    
      <item>
        <title>右值引用</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/rvalue-reference/</link>
        <pubDate>Sat, 03 Jun 2023 15:51:24 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/rvalue-reference/</guid>
        <description>左值与右值 C++03标准 C++03标准中将表达式分为左值与右值，并且非左即右：
左值：表达式结束后依然存在的持久对象，可以出现在赋值号的左侧与右侧，可以寻址 右值：表达式结束后就不再存在的临时对象，只可以出现在赋值号的右侧，不可寻址 C++11标准 C++11对左值、右值的分类重新进行了定义，在C++11标准中，表达式有以下两个属性：
有身份：指代某个非临时对象 可被移动：可被右值引用类型匹配 根据以上两个属性可以得到4种组合：
有身份，不可移动：左值，与C++03中的左值相同 无身份，可移动：纯右值，与C++03中的右值相同 有身份，可移动：将亡值，即生命周期即将结束的值，为C++11中新增加的类型 无身份，不可移动：无意义 将亡值与纯右值合称为右值。
右值引用 C++11之前的引用类型全部为左值引用，用&amp;amp;符号声明。一般来说，左值引用必须绑定左值：
// num为左值 int num = 10; // 正确，a为左值num的引用 int &amp;amp;a = num; // 错误，10为右值，不能使用左值引用绑定 int &amp;amp;b = 10; 但是有个例外，可以将const左值引用绑定至右值：
const int &amp;amp;c = 10; C++11中添加了右值引用类型，用&amp;amp;&amp;amp;符号声明，右值引用只能绑定右值：
// num为左值 int num = 10; // 错误，右值引用不能绑定左值 int &amp;amp;&amp;amp;a = num; // 正确，右值引用绑定纯右值 int &amp;amp;&amp;amp;b = 10; 右值引用的主要作用是用于实现移动语义与完美转发。
移动语义 在没有右值引用之前，C++中只存在“拷贝语义”，通过使用拷贝构造函数或拷贝赋值运算符（它们的参数为左值引用）可以将一个对象进行拷贝：
class A { public: A() {} ~A() {} // 拷贝构造函数 A(const A &amp;amp;rhs) {} // 拷贝赋值运算符 A &amp;amp;operator=(const A &amp;amp;rhs) { return *this; } }; int main() { A a1; // 使用拷贝构造函数进行对象拷贝 A a2(a1); A a3 = a1; // 使用拷贝赋值运算符进行对象拷贝 A a4; a4 = a1; } 此时，如果要将一个即将析构的对象赋值给一个新对象，仍然需要先进行拷贝再进行析构，这样运行效率较低。由于原对象即将析构，因此可以将其中的资源移动至新对象，从而减少一次资源复制。</description>
      </item>
    
      <item>
        <title>二、所有权与借用</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/ownership-and-borrowing/</link>
        <pubDate>Fri, 17 Mar 2023 19:43:21 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/ownership-and-borrowing/</guid>
        <description>RAII（资源获取即初始化） 为了能够正常释放资源，避免出现C/C++中很容易出现的资源泄漏，Rust强制执行RAII。RAII要求任何对象在离开其作用域时，必须调用其析构函数并释放资源。Rust中的析构函数通过Drop特性实现。
fn create_box() { // 在函数中申请堆上资源 let _box1 = Box::new(3i32); // 函数结束时释放_box1 } fn main() { // 在主函数中申请堆上资源 let _box2 = Box::new(5i32); { // 在一个代码块中申请堆上资源 let _box3 = Box::new(4i32); // 代码块结束时释放_box3 } // 申请很多资源，无需手动释放 for _ in 0u32..1_000 { create_box(); } // 主函数结束时释放_box2 } 所有权与移动语义 所有权：为了能够安全地释放资源，Rust引入了所有权规则：
每个变量有且只能有一个所有者 在退出作用域时，所有者负责释放资源 这避免了多次释放同一资源，另外也有一些变量不拥有资源（即引用）。
移动语义：默认情况下，在使用let进行赋值，或者向函数传递参数时，所有权会进行转移。在进行移动后，原来的变量不能再使用，这避免了悬挂指针。
// 此函数获取堆上资源的所有权 fn destroy_box(c: Box&amp;lt;i32&amp;gt;) { println!(&amp;#34;Destroying a box that contains {}&amp;#34;, c); // 函数结束时c被释放 } // 栈上资源只会进行复制 let x = 5u32; let y = x; // 堆上资源会进行移动，移动后a不能再使用 let a = Box::new(5i32); let b = a; // 调用函数将b的所有权移动到函数中，移动后b不能再使用 destroy_box(b); 可变性变化 变量的可变性在移动时可以进行变化。</description>
      </item>
    
      <item>
        <title>基础 - 工作流</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/workflow/</link>
        <pubDate>Wed, 22 Nov 2023 10:08:34 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/workflow/</guid>
        <description>简介 Qlib中设计了很多模块/组件，在进行实验时需要将多个组件组成一个工作流。组成工作流的方式有两种：
使用python代码将组件组合成工作流（例子) 使用Qlib提供的qrun程序，它可以根据配置文件自动运行整个工作流 一个完整的qrun工作流包括以下步骤：
数据 加载 处理 切片 模型 训练与推理 保存与加载 评估 预测信号分析 回测 Qlib还有一套完整的记录系统用于记录训练、推理与评估阶段的所有信息与结果。
完整例子 下面是qrun的一个典型的配置文件，定义了量化研究的典型工作流：
qlib_init: provider_uri: &amp;#34;~/.qlib/qlib_data/cn_data&amp;#34; region: cn market: &amp;amp;market csi300 benchmark: &amp;amp;benchmark SH000300 data_handler_config: &amp;amp;data_handler_config start_time: 2008-01-01 end_time: 2020-08-01 fit_start_time: 2008-01-01 fit_end_time: 2014-12-31 instruments: *market port_analysis_config: &amp;amp;port_analysis_config strategy: class: TopkDropoutStrategy module_path: qlib.contrib.strategy.strategy kwargs: topk: 50 n_drop: 5 signal: &amp;lt;PRED&amp;gt; backtest: limit_threshold: 0.095 account: 100000000 benchmark: *benchmark deal_price: close open_cost: 0.0005 close_cost: 0.0015 min_cost: 5 task: model: class: LGBModel module_path: qlib.</description>
      </item>
    
      <item>
        <title>函数对象与lambda表达式</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/function-object-and-lambda-expression/</link>
        <pubDate>Mon, 05 Jun 2023 20:29:17 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/function-object-and-lambda-expression/</guid>
        <description>函数对象 函数对象（仿函数/函子）指实现了operator()运算符的类的对象，它的调用方式与函数类似。相对于直接函数调用，函数对象有两个优势：
函数对象可包含状态 函数对象是一个类型，因此可用作模板参数 class Plus { public: int operator()(int a, int b) { return a + b; } }; int main() { Plus plus; int n = plus(11, 22); } lambda表达式 lambda表达式是C++11引入的一个语法糖，使用它可以方便快捷地创建一个匿名函数对象。
int main() { auto plus = [](int a, int b) { return a + b; }; int n = plus(11, 22); } 组成 一个完整lambda表达式的组成如下：
[ capture-list ] ( params ) mutable(optional) exception(optional) -&amp;gt; ret(optional) { body } 捕获列表（capture-list） 参数列表（params） mutable标识（mutable，可选） 异常标识（exception，可选） 返回类型（ret，可选） 函数体（body） 其中，参数列表、异常标识、返回类型、函数体4部分都与函数基本相同，其它部分说明如下：</description>
      </item>
    
      <item>
        <title>三、控制流</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/control-flow/</link>
        <pubDate>Sat, 18 Mar 2023 00:49:56 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/control-flow/</guid>
        <description>分支语句（if-else） 分支语句if-else的用法基本与其它语言相同。
// 单独使用if，使用if-else，或者使用if-else if-else等均可 if n &amp;lt; 0 { print!(&amp;#34;{} is negative&amp;#34;, n); } else if n &amp;gt; 0 { print!(&amp;#34;{} is positive&amp;#34;, n); } else { print!(&amp;#34;{} is zero&amp;#34;, n); } // if-else语句是表达式，可以作为值使用，但是所有分支的返回值类型必须相同 let big_n = if n &amp;lt; 10 &amp;amp;&amp;amp; n &amp;gt; -10 { println!(&amp;#34;, and is a small number, increase ten-fold&amp;#34;); 10 * n } else { println!(&amp;#34;, and is a big number, halve the number&amp;#34;); n / 2 }; 循环语句 无限循环（loop） 无限循环语句，只能使用break或return退出。</description>
      </item>
    
      <item>
        <title>基础 - 数据框架</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/data-framework/</link>
        <pubDate>Wed, 22 Nov 2023 11:48:12 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/data-framework/</guid>
        <description>简介 Qlib的数据框架提供了友好的API用于管理与检索数据，以及高性能的数据基础设施。它是专门为量化投资设计的，例如，用户可以轻松地建立公式化alpha。
下面是使用Qlib数据工作流的一个典型的例子：
下载基础数据并转换为Qlib格式（后缀名为.bin） 使用Qlib表达式引擎建立一些基本特征，例如Ref($close, 60) / $close表示最近60个交易日的回报率。这一步骤通常实现在数据处理器中的数据加载器组件内 如果用户需要更加复杂的数据处理（如数据归一化），数据处理器模块支持用户自定义处理器。处理器可以实现表达式引擎难以支持的复杂数据处理方法 基于预处理的数据生成模型所需的数据集 数据预处理 Qlib格式数据 Qlib专门设计了一种数据结构用于处理财务数据，此类数据被存储于.bin文件中。
Qlib提供了两个现成的数据集：
数据集 美国市场 中国市场 Alpha360 √ √ Alpha158 √ √ 同时Qlib也提供了一个高频数据集。
Qlib格式数据集 Qlib提供脚本scripts/get_data.py用于下载数据集。使用如下命令下载中国市场股票数据集：
# 下载日线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/cn_data --region cn # 下载分钟线数据 python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/qlib_cn_1min --region cn --interval 1min 也可以下载美国市场股票数据集：
python scripts/get_data.py qlib_data --target_dir ~/.qlib/qlib_data/us_data --region us 运行上述命令后，中国市场与美国市场股票数据集分别保存于~/.qlib/qlib_data/cn_data和~/.qlib/qlib_data/us_data目录中。
Qlib也提供一个脚本scripts/data_collector帮助用户爬取最新数据并转换为Qlib格式。
自动更新数据 强烈建议用户先手动更新数据一次，之后设置为自动更新：
手动更新数据 python scripts/data_collector/yahoo/collector.py update_data_to_bin --qlib_data_1d_dir &amp;lt;user data dir&amp;gt; --trading_date &amp;lt;start date&amp;gt; --end_date &amp;lt;end date&amp;gt; 其中参数trading_date为交易开始日期，end_date为交易结束日期（不包含）。</description>
      </item>
    
      <item>
        <title>std::function与std::bind</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/std-function-and-std-bind/</link>
        <pubDate>Mon, 05 Jun 2023 20:57:03 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/std-function-and-std-bind/</guid>
        <description>std::function 类模板std::function是通用多态函数封装器。std::function的实例能存储、复制及调用任何可调用目标，包括：
函数/函数指针 函数对象 lambda表达式 成员函数指针 数据成员指针 作用 调用者可使用统一的方式调用可调用目标，无需关心绑定的具体类型 一种类型的std::function对象可绑定多种类型的可调用目标，实现多态的效果（例如用于回调函数） 例子 struct Foo { Foo(int num) : num_(num) {} void print_add(int i) const { std::cout &amp;lt;&amp;lt; num_ + i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } int num_; }; void print_num(int i) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } struct PrintNum { void operator()(int i) const { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } }; int main() { // 存储函数 std::function&amp;lt;void(int)&amp;gt; f1 = print_num; f1(-9); // 存储lambda表达式 std::function&amp;lt;void()&amp;gt; f2 = []() { print_num(42); }; f2(); // 存储std::bind的结果 std::function&amp;lt;void()&amp;gt; f3 = std::bind(print_num, 31337); f3(); // 存储成员函数指针 std::function&amp;lt;void(const Foo &amp;amp;, int)&amp;gt; f4 = &amp;amp;Foo::print_add; const Foo foo(314159); f4(foo, 1); f4(314159, 1); // 存储数据成员指针 std::function&amp;lt;int(Foo const &amp;amp;)&amp;gt; f5 = &amp;amp;Foo::num_; std::cout &amp;lt;&amp;lt; f5(foo) &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; // 存储成员函数指针，绑定对象 using std::placeholders::_1; std::function&amp;lt;void(int)&amp;gt; f6 = std::bind(&amp;amp;Foo::print_add, foo, _1); f6(2); // 存储成员函数指针，绑定对象指针 std::function&amp;lt;void(int)&amp;gt; f7 = std::bind(&amp;amp;Foo::print_add, &amp;amp;foo, _1); f7(3); // 存储函数对象 std::function&amp;lt;void(int)&amp;gt; f8 = PrintNum(); f8(18); } std::bind std::bind函数将可调用目标与指定参数进行绑定，并以函数对象的形式保存。调用此函数对象相当于使用绑定的参数调用原可调用目标。如果有的参数不能在绑定时确定，可以使用std::placeholders中的占位符占位，并延迟到调用时再传入。</description>
      </item>
    
      <item>
        <title>四、函数与闭包</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/functions-and-closures/</link>
        <pubDate>Sun, 19 Mar 2023 00:40:01 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/functions-and-closures/</guid>
        <description>函数 函数使用fn关键字声明，如有需要，则指定参数名称与类型，以及返回值的类型。返回方式除了可以使用return外，还可以在最后一条语句给出一个表达式。
fn add_one(x: i32) -&amp;gt; i32 { x + 1 } 语句与表达式 Rust程序由语句组成，常见的语句有let语句与表达式语句 代码块也是表达式，它的最后一个表达式被返回。需要注意的是，如果最后一个表达式以分号结尾，则返回值为() 函数指针 函数指针的类型是fn，在使用时还需要指定输入输出类型。
fn do_twice(f: fn(i32) -&amp;gt; i32, arg: i32) -&amp;gt; i32 { f(arg) + f(arg) } // 将add_one函数指针作为do_twice的参数 let answer = do_twice(add_one, 5); 函数指针fn是一个类型，所以在作为参数时可以直接使用，而无需使用泛型并使用闭包特性进行限制。此外，fn实现了全部3种闭包特性（Fn，FnMut与FnOnce），这意味着可以将函数指针传给所有将闭包作为参数的函数。因此，在写函数时最好使用泛型与闭包特性，这样函数与闭包都可以作为参数。
但是，在与外部代码交互时，可能只接收函数指针作为参数。
闭包 闭包是可以捕获环境中变量的函数，相当于lambda表达式。
// 一个捕获了变量x的闭包 |val| val + x 闭包的特点有：
使用||代替() 如果只有一条语句可以省略{} 可以捕获环境中的变量 捕获变量 闭包可以捕获环境中的变量。可以通过以下3种方式：
引用：&amp;amp;T 可变引用：&amp;amp;mut T 值：T // 引用捕获 let color = String::from(&amp;#34;green&amp;#34;); let print = || println!(&amp;#34;`color`: {}&amp;#34;, color); print(); // 可变引用捕获 let mut count = 0; let mut inc = || { count += 1; println!</description>
      </item>
    
      <item>
        <title>基础 - 模型</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/model/</link>
        <pubDate>Thu, 23 Nov 2023 09:43:29 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/model/</guid>
        <description>简介 模型用于计算股票的预测分数。Qlib提供了基类Model，所有模型都必须继承它；另外还提供了基类ModelFT，包含了用于微调的方法。
例子 Qlib的模型库中包含了LightGBM、MLP、LSTM等模型，它们被视为基线模型。下面的例子展示了如何将LightGBM作为独立模块使用：
from qlib.contrib.model.gbdt import LGBModel from qlib.contrib.data.handler import Alpha158 from qlib.utils import init_instance_by_config, flatten_dict from qlib.workflow import R from qlib.workflow.record_temp import SignalRecord, PortAnaRecord market = &amp;#34;csi300&amp;#34; benchmark = &amp;#34;SH000300&amp;#34; data_handler_config = { &amp;#34;start_time&amp;#34;: &amp;#34;2008-01-01&amp;#34;, &amp;#34;end_time&amp;#34;: &amp;#34;2020-08-01&amp;#34;, &amp;#34;fit_start_time&amp;#34;: &amp;#34;2008-01-01&amp;#34;, &amp;#34;fit_end_time&amp;#34;: &amp;#34;2014-12-31&amp;#34;, &amp;#34;instruments&amp;#34;: market, } task = { &amp;#34;model&amp;#34;: { &amp;#34;class&amp;#34;: &amp;#34;LGBModel&amp;#34;, &amp;#34;module_path&amp;#34;: &amp;#34;qlib.contrib.model.gbdt&amp;#34;, &amp;#34;kwargs&amp;#34;: { &amp;#34;loss&amp;#34;: &amp;#34;mse&amp;#34;, &amp;#34;colsample_bytree&amp;#34;: 0.8879, &amp;#34;learning_rate&amp;#34;: 0.0421, &amp;#34;subsample&amp;#34;: 0.8789, &amp;#34;lambda_l1&amp;#34;: 205.6999, &amp;#34;lambda_l2&amp;#34;: 580.9768, &amp;#34;max_depth&amp;#34;: 8, &amp;#34;num_leaves&amp;#34;: 210, &amp;#34;num_threads&amp;#34;: 20, }, }, &amp;#34;dataset&amp;#34;: { &amp;#34;class&amp;#34;: &amp;#34;DatasetH&amp;#34;, &amp;#34;module_path&amp;#34;: &amp;#34;qlib.</description>
      </item>
    
      <item>
        <title>类型推导</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/type-deduction/</link>
        <pubDate>Tue, 06 Jun 2023 21:10:22 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/type-deduction/</guid>
        <description>C++是强类型语言，使用每个变量前必须声明其类型。如果不进行类型推导，则用户必须自行声明所有变量的类型，对于一些复杂的类型（如容器的迭代器）或临时类型（如lambda表达式），这是没有意义甚至无法完成的。为此，C++11标准引入了auto与decltype两个关键字用于进行类型推导，使得编译器可以自动推导出变量的类型。这样做有以下好处：
鲁棒性：即使更改表达式的类型也能正常工作 性能：可以保证没有进行转换 可用性：不必担心类型名称拼写困难或拼写有误 效率：代码会变得更高效 auto 在C++11之前，auto关键字为存储期说明符，但是基本不使用。C++11之后将此关键字用于类型推导，其基本语法是：
auto 变量名 初始化器; 基本用法 // 通用初始化语法 auto a{42}; // 赋值语法 auto b = 0; // 通用赋值语法，它结合了上述两种形式 auto c = {3.14159}; // 直接初始化或构造函数样式的语法 auto d(1.41421f); // 通过表达式推导 auto e = 1 + 2; // 通过函数返回值推导 auto f = add(1, 1.2); // 推导new操作符结果 auto g = new auto(10); // 推导lambda表达式类型 auto lambda1 = [](int x) { return x + 3; }; // 可在一行定义多个变量，但是不能出现冲突 auto x = a, &amp;amp;y = b, *z = &amp;amp;e; // C++14后可自动推导函数返回值 auto func() { return 2 + 3; } // C++14后可自动推导lambda函数的参数 auto lambda2 = [](auto a) { return a; }; // C++17后可自动推导非类型模板参数 template &amp;lt;auto I&amp;gt; struct A; // 在for循环中使用 auto vec = std::vector&amp;lt;int&amp;gt;(); for (auto it = vec.</description>
      </item>
    
      <item>
        <title>五、类型</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/types/</link>
        <pubDate>Mon, 20 Mar 2023 23:37:45 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/types/</guid>
        <description>内置类型 标量类型 有符号整型：i8, i16, i32, i64, i128, isize 无符号整型：u8, u16, u32, u64, u128, usize 浮点型：f32, f64 字符型：char（4字节Unicode字符） 布尔型：bool（true/false） unit类型：类型为()，有且仅有一个值()。类似void 复合类型 复合类型有元组与数组两种，它们的长度与其中变量的类型在声明后均不可变。
元组：由多个不同类型的变量组成 let x: (i32, f64, u8) = (-1, 2.0, 3); // 声明元组 let a = x.0; // 取元组中的元素 let (a, b, c) = x; // 解构 数组：由多个同一类型的变量组成 let a: [i32; 5] = [1, 2, 3, 4, 5]; // 声明数组 let a = [3; 5]; // 使用同一变量初始化 let x = a[0]; // 取数组中的元素 切片：使用切片可以更加方便地操作序列数据，但是它本身不包含数据，只是一种引用，包含起始位置与长度两个字段 let a: [i32; 5] = [1, 2, 3, 4, 5]; // 声明数组 let s: &amp;amp;[i32] = &amp;amp;a[1.</description>
      </item>
    
      <item>
        <title>基础 - 投资组合策略</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/portfolio-strategy/</link>
        <pubDate>Thu, 23 Nov 2023 10:39:32 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/portfolio-strategy/</guid>
        <description>简介 投资组合策略可以根据模型的预测分数生成投资组合。Qlib提供了一些已实现的投资组合策略，同时也支持用户根据需要进行自定义。在确定了模型（预测信号）与策略后，运行回测可以检查它们的性能。
基类 BaseStrategy 此类是所有策略类的基类，用户可以继承此类并实现其接口以添加自定义策略。其接口有：
generate_trade_decision：一个关键接口，用于在每个交易周期生成交易决策。其调用频率取决于执行器，但是实际交易频率可以由用户代码控制 WeightStrategyBase 此类只专注于目标仓位，并基于仓位自动生成订单。其接口有：
generate_target_weight_position 根据当前仓位与交易日期生成目标仓位（不考虑现金） 返回目标仓位（所有资产的百分比） 该类按照如下方式实现了generate_order_list接口：
调用generate_target_weight_position方法生成目标仓位 根据目标仓位生成股票的目标数量 根据股票的目标数量生成订单 已实现的策略 TopkDropoutStrategy 该类按照如下方式实现了generate_order_list接口：
执行Topk-Drop算法计算每支股票的目标数量 根据股票的目标数量生成订单 EnhancedIndexingStrategy 该策略将主动管理与被动管理相结合，目标是在控制风险敞口的同时取得超出基准指数的收益。
例子 预测分数 预测分数是一个pandas的DataFrame对象，它的索引是&amp;lt;datetime(pd.Timestamp), instrument(str)&amp;gt;且必须包含分数列。一个例子如下：
datetime instrument score 2019-01-04 SH600000 -0.505488 2019-01-04 SZ002531 -0.320391 2019-01-04 SZ000999 0.583808 2019-01-04 SZ300569 0.819628 2019-01-04 SZ001696 -0.137140 ... ... 2019-04-30 SZ000996 -1.027618 2019-04-30 SH603127 0.225677 2019-04-30 SH603126 0.462443 2019-04-30 SH603133 -0.302460 2019-04-30 SZ300760 -0.126383 注意预测分数不一定是收益率，不同模型有不同的定义。
运行回测 大多数情况下，用户可以使用backtest_daily回测他们的投资组合策略： from pprint import pprint import qlib import pandas as pd from qlib.</description>
      </item>
    
      <item>
        <title>const与constexpr</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/const-and-constexpr/</link>
        <pubDate>Wed, 07 Jun 2023 01:08:48 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/const-and-constexpr/</guid>
        <description>const C++11之前就存在const关键字，用于进行常量相关操作。它的主要用法如下：
// 定义常量，使其不能修改 const int value = 5; // 可以使用常量定义数组 char arr[value]; char s[10]; // 指针不可修改，指向的内容可修改 char *const ptr1 = s; // 指针可修改，指向的内容不可修改 const char *ptr2; // 指针与指向的内容均不可修改 const char *const ptr3 = &amp;#34;string&amp;#34;; // 修饰函数参数，使其不可修改，如果同时使用引用可避免复制对象 void func(const A &amp;amp;a); // 修饰成员变量，使其不能修改，只能进行初始化 class A { const int value = 5; }; class B { const int value; B(int v) : value(v) {} }; // 修饰成员函数，使其不能修改成员变量 class C { public: void func() const {} }; // 修饰对象，使其只能调用const成员函数 const C c; c.</description>
      </item>
    
      <item>
        <title>六、泛型</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/generics/</link>
        <pubDate>Tue, 21 Mar 2023 14:00:03 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/generics/</guid>
        <description>泛型是用于编写功能确定，类型待定的代码模板的机制，可以有效减少代码冗余。类似于C++中的模板。
在函数中使用 // 定义一个使用泛型的函数 fn foo&amp;lt;T&amp;gt;(arg: T) { ... } // 编译器自动识别T为i32 foo(1); // 编译器自动识别T为&amp;amp;str foo(&amp;#34;string&amp;#34;); // 手动设置T为i32 foo::&amp;lt;i32&amp;gt;(1); 在结构体中使用 // 定义一个使用泛型的结构体 struct Point&amp;lt;T&amp;gt; { x: T, y: T, } // 自动识别T为i32 let integer = Point { x: 5, y: 10 }; // 自动识别T为f64 let float = Point { x: 1.0, y: 4.0 }; // 错误，x与y必须具有相同的类型 let wont_work = Point { x: 5, y: 4.0 }; // 手动设置T为u8 let uint8 = Point::&amp;lt;u8&amp;gt; { x: 1, y: 2 }; 在枚举中使用 std库中的Option与Result是非常常用的使用了泛型的枚举结构。</description>
      </item>
    
      <item>
        <title>基础 - 实验管理系统</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/experiment-management/</link>
        <pubDate>Thu, 23 Nov 2023 14:44:47 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/experiment-management/</guid>
        <description>简介 Qlib包含一个实验管理系统，名为QlibRecorder，它可以帮助用户高效地管理实验与分析结果。该系统有三个组件：
实验管理器：用于管理实验 实验：每个实例代表一个实验 记录器：每个实例负责记录一次实验运行 该系统定义了一系列接口，还提供了一个具体的实现MLflowExpManager，该实现基于机器学习平台MLFlow。如果用户使用了该实现，则可以使用命令mlflow ui来可视化与检查实验结果。
QlibRecorder QlibRecorder为用户提供了一套高级API来使用实验管理系统，该接口被封装为R，用户可以直接使用R与系统交互。导入R的代码如下：
from qlib.workflow import R QlibRecorder还包括一些公用API用来在工作流中管理实验与记录器。
实验管理器 ExpManager ExpManager模块负责管理不同的实验，大部分API与QlibRecorder相同，其中最重要的API是get_exp方法。
实验 Experiment Experiment类负责处理与一个实验相关的所有操作，其中包括开始、结束实验等基本方法，以及与记录器相关的方法，如get_recorder和list_recorders。
Qlib提供了一个默认的实验，在某些特定情况下，如用户调用log_metrics或get_exp等API时，该实验被自动创建并使用。如果使用默认实验，则会产生相关的日志信息。用户可以在配置文件中或初始化时修改默认实验的名称。
记录器 Recorder Recorder类负责在一次实验运行中帮助用户方便地跟踪实验结果以及生成的其它信息。
记录模板 RecordTemp RecordTemp类用于按照指定格式生成实验结果。Qlib提供了三个记录模板类：
SignalRecord：生成模型的预测结果 SigAnaRecord：生成模型的IC/ICIR/Rank IC/Rank ICIR from qlib.contrib.eva.alpha import calc_ic, calc_long_short_return ic, ric = calc_ic(pred.iloc[:, 0], label.iloc[:, 0]) long_short_r, long_avg_r = calc_long_short_return(pred.iloc[:, 0], label.iloc[:, 0]) PortAnaRecord：生成回测结果 from qlib.contrib.strategy.strategy import TopkDropoutStrategy from qlib.contrib.evaluate import ( backtest as normal_backtest, risk_analysis, ) # 回测 STRATEGY_CONFIG = { &amp;#34;topk&amp;#34;: 50, &amp;#34;n_drop&amp;#34;: 5, } BACKTEST_CONFIG = { &amp;#34;limit_threshold&amp;#34;: 0.</description>
      </item>
    
      <item>
        <title>枚举</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/enumeration/</link>
        <pubDate>Wed, 07 Jun 2023 23:54:06 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/enumeration/</guid>
        <description>无作用域枚举（enum） C++11之前存在的枚举为无作用域枚举，使用enum关键字声明：
enum Color { red, green, blue }; 每个枚举项都成为该枚举类型的一个具名常量，在它的外围作用域可见，且可以用于要求常量的任何位置：
Color r = red; 每个枚举类型都有一个底层类型，可以显式指定底层类型：
enum smallenum : std::int16_t { a, b, c }; 可以在枚举项列表中提供初始化器，各枚举项的值由那些初始化器所定义。如果首个枚举项无初始化器，那么它的关联值为零。对于其他任何定义中无初始化器的枚举项，它的关联值是前一枚举项加一：
enum Foo { a, b, c = 10, d, e = 1, f, g = f + c }; 无作用域枚举类型的值可隐式转换到整型类型：
int n = blue; 无作用域枚举的名字可以忽略：
enum { a, b, c = 0, d = a + 2 }; 使用无作用域枚举可能产生以下问题：
由于枚举项在任何作用域可见，因此容易与其它变量名称产生冲突 由于枚举项可隐式转换到整型类型，因此有时会发生未预期的转换 有作用域枚举（enum class或enum struct） C++11引入新的有作用域枚举，使用enum class或enum struct关键字声明：</description>
      </item>
    
      <item>
        <title>七、特性</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/traits/</link>
        <pubDate>Wed, 22 Mar 2023 17:50:53 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/traits/</guid>
        <description>特性是为未知类型Self定义的一组方法，类似于Java的接口。特性可以为任意类型实现，包括内置类型，如i64/&amp;amp;str等。
定义特性 // 定义一个特性，无需实现 pub trait Summary { fn summarize(&amp;amp;self) -&amp;gt; String; } // 定义特性时可以提供默认实现 pub trait Summary { fn summarize(&amp;amp;self) -&amp;gt; String { String::from(&amp;#34;(Read more...)&amp;#34;) } } 实现特性 特性必须为某个类型实现，可以认为是为这个类型添加了相应的方法。
impl Summary for NewsArticle { fn summarize(&amp;amp;self) -&amp;gt; String { format!(&amp;#34;{}, by {} ({})&amp;#34;, self.headline, self.author, self.location) } } 使用impl Trait impl Trait是一个语法糖，它相当于在泛型函数中使用泛型范围（trait bound）。可以将impl Trait作为函数的输入参数或者返回值，使代码更简洁易读，但是需要注意此时的函数是静态泛型函数，并不能动态接收或返回不同的类型。
作为输入参数 // 使用impl Trait作为输入参数 pub fn notify(item: &amp;amp;impl Summary) { println!(&amp;#34;Breaking news! {}&amp;#34;, item.summarize()); } // 使用+表示参数需要实现多个特性 pub fn notify(item: &amp;amp;(impl Summary + Display)) {} 作为返回值 // 使用impl Trait作为返回值 fn returns_summarizable() -&amp;gt; impl Summary {} 使用dyn返回实现特性的动态类型 Rust编译器必须知道函数返回值占用空间的大小，但是对于同样一个特性，不同的实现类型占用空间不同，因此不能直接将特性作为返回值。但是，可以通过返回一个Box指向一个实现特性的变量来解决这一问题。由于Box大小确定，因此这是可行的。由于Rust要求在堆上分配内存时必须显示说明，因此这种情况下需要使用dyn关键字。</description>
      </item>
    
      <item>
        <title>基础 - 图形分析</title>
        <link>https://zqwang-cn.github.io/qlib-study-notes/analysis/</link>
        <pubDate>Thu, 23 Nov 2023 16:01:57 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/qlib-study-notes/analysis/</guid>
        <description> 简介 本模块用于展示日内交易的图形报表，从而帮助用户从视觉上评估与分析投资组合。下面是一些可用报表：
analysis_position：仓位分析 report_graph：回测报表 score_ic_graph：分数IC报表 cumulative_return_graph：累积回报率报表 risk_analysis_graph：风险分析报表 rank_label_graph：排名标签报表 analysis_model：模型分析 model_performance_graph：模型性能报表 所有图形报表 使用如下代码获取所有支持的报表：
&amp;gt;&amp;gt; import qlib.contrib.report as qcr &amp;gt;&amp;gt; print(qcr.GRAPH_NAME_LIST) [&amp;#39;analysis_position.report_graph&amp;#39;, &amp;#39;analysis_position.score_ic_graph&amp;#39;, &amp;#39;analysis_position.cumulative_return_graph&amp;#39;, &amp;#39;analysis_position.risk_analysis_graph&amp;#39;, &amp;#39;analysis_position.rank_label_graph&amp;#39;, &amp;#39;analysis_model.model_performance_graph&amp;#39;] </description>
      </item>
    
      <item>
        <title>列表初始化</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/list-initialization/</link>
        <pubDate>Thu, 08 Jun 2023 00:42:33 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/list-initialization/</guid>
        <description>列表初始化是使用花括号初始化器对变量进行初始化的方式。C++11之前只能用于数组等少量类型，C++11后将这种方式推广至所有类型。
初始化非类类型 // 不使用列表初始化 int a; // 默认初始化，值不确定 int b = int(); // 零初始化 int c(1); // 直接初始化 int d = 1; // 复制初始化 // 使用列表初始化 int e{}; // 零初始化 int f{1}; // 直接初始化 int g = {1}; // 复制初始化 int h = int{1}; // 直接初始化临时量，然后复制初始化 // 列表初始化引用 const int &amp;amp;r1 = {1}; // 绑定const左值引用到临时变量 int &amp;amp;&amp;amp;r2 = {1}; // 绑定右值引用到临时变量 int &amp;amp;r3 = {2}; // 错误，不能绑定右值到非const左值引用 初始化类类型 初始化聚合类型 聚合类型是下列类型之一：</description>
      </item>
    
      <item>
        <title>八、标准库 - 常用集合类型</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-common-collections/</link>
        <pubDate>Thu, 23 Mar 2023 12:51:57 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-common-collections/</guid>
        <description>Vec Vec是长度可变的数组，它在堆上分配空间，且能自动进行内存管理，类似于C++的std::vector。一个Vec包含3个参数：
数据指针 长度 容量 // 建立空Vec let v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // 使用初始值建立Vec let v = vec![1, 2, 3]; // 添加值 v.push(4); // 获取值 let third: &amp;amp;i32 = &amp;amp;v[2]; let third: Option&amp;lt;&amp;amp;i32&amp;gt; = v.get(2); // 迭代值 for i in &amp;amp;v { println!(&amp;#34;{i}&amp;#34;); } for i in &amp;amp;mut v { *i += 50; } String String是在堆上分配空间的动态字符串类型（区别于内置静态字符串类型&amp;amp;str），类似于C++的std::string。String底层存储使用Vec&amp;lt;u8&amp;gt;类型，但是保证总是有效的UTF8编码字符串。因此String中每个字符的大小不一致，需要小心使用。
// 建立空String let mut s = String::new(); // 将&amp;amp;str转换为String let s = &amp;#34;initial contents&amp;#34;.</description>
      </item>
    
      <item>
        <title>元组与结构化绑定</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/tuple-and-structured-binding/</link>
        <pubDate>Thu, 08 Jun 2023 21:49:57 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/tuple-and-structured-binding/</guid>
        <description>元组 有时需要将多个不同类型的变量聚合为一个新类型，虽然使用类或结构体即可实现此功能，但是它们都需要提前声明并指定一个类型名称。很多情况下用户并不会重复使用该类型，或者并不关心该类型的名称，但是希望能够更加简单地实现该功能。为了解决此问题，C++11中引入了元组。元组类模板std::tuple是固定大小的异类值汇集。它是std::pair的泛用形式。
std::tuple&amp;lt;int, std::string, double&amp;gt; t1; // 用默认值初始化 std::tuple&amp;lt;int, std::string, double&amp;gt; t2{42, &amp;#34;Test&amp;#34;, -3.14}; // 列表初始化 std::tuple&amp;lt;char, std::string, int&amp;gt; t3{t2}; // 隐式转换 std::tuple&amp;lt;int, double&amp;gt; t4{std::make_pair(42, 3.14)}; // 从pair创建 auto t5 = std::make_tuple(1, 2.0f, 3.14, &amp;#34;string&amp;#34;); // 使用make_tuple创建 auto t6 = std::tuple_cat(t1, t2, t3); // 拼接元组 int size = std::tuple_size&amp;lt;decltype(t1)&amp;gt;::value; // 获取元素个数 int a = std::get&amp;lt;0&amp;gt;(t1); // 提取单个元素 std::get&amp;lt;0&amp;gt;(t1) = 0; // 修改单个元素 int a1; std::string b1; double c1; std::tie(a1, b1, c1) = t1; // 解包元素 const auto [a2, b2, c2] = t2; // 结构化绑定 结构化绑定 结构化绑定用于将一组变量绑定至一个复合结构的所有子元素上，该复合结构可以为数组、元组或结构体。虽然也可以使用赋值语句逐一进行绑定，但是结构化绑定极大地简化了这一操作。</description>
      </item>
    
      <item>
        <title>九、标准库 - 智能指针</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-smart-pointers/</link>
        <pubDate>Fri, 24 Mar 2023 13:53:31 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-smart-pointers/</guid>
        <description>Box Box是最简单的智能指针，它在堆上分配内存。Box只能有一个持有者，类似于C++的std::unique_ptr。Box没有性能开销，同时也没有额外功能。一般在以下情况下使用
要使用一个在编译期无法知道大小的类型 要转换大量数据的所有权但是不想拷贝数据 要使用实现了某个特性，但并不关心其具体类型的类型 // 声明一个Box并储存一个值 let a = Box::new(5); // 取Box中储存的值（解引用，需要实现Deref特性） let b = *a; // 强制解引 println!(&amp;#34;a = {}&amp;#34;, a); // 提前释放内存（可自动释放，需要实现Drop特性） drop(a); Rc Rc是带引用计数的智能指针，可以有多个持有者，类似于C++的std::shared_ptr。
// 声明一个Rc并储存一个值 let rc_a: Rc&amp;lt;String&amp;gt; = Rc::new(&amp;#34;Rc examples&amp;#34;.to_string()); // 复制指针（底层数据不变，引用计数+1） let rc_b: Rc&amp;lt;String&amp;gt; = Rc::clone(&amp;amp;rc_a); // 查看引用计数 println!(&amp;#34;Reference Count of rc_a: {}&amp;#34;, Rc::strong_count(&amp;amp;rc_a)); // 判断两个Rc是否指向同一数据 println!(&amp;#34;rc_a and rc_b are equal: {}&amp;#34;, rc_a.eq(&amp;amp;rc_b)); // 通过Rc直接使用底层数据的方法 println!(&amp;#34;Length of the value inside rc_a: {}&amp;#34;, rc_a.</description>
      </item>
    
      <item>
        <title>类中的新特性</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/new-features-in-class/</link>
        <pubDate>Thu, 08 Jun 2023 23:06:07 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/new-features-in-class/</guid>
        <description>委托构造 同一个类中的一个构造函数可以调用另一个构造函数，从而达到简化代码的目的：
class Base { public: Base() { value1 = 1; } Base(int value) : Base() // 委托Base()构造函数 { value2 = 2; } private: int value1; int value2; }; 继承构造 假设父类有多个版本的构造函数，即使子类不进行修改，也必须编写同样多的构造函数，将参数透传至父类，例如：
class A { public: A(int i) {} A(double d, int i) {} A(float f, int i, const char *c) {} //...... }; class B : public A { public: B(int i) : A(i) {} B(double d, int i) : A(d, i) {} B(float f, int i, const char *c) : A(f, i, c) {} //.</description>
      </item>
    
      <item>
        <title>十、标准库 - 并发</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-concurrency/</link>
        <pubDate>Sat, 25 Mar 2023 23:12:30 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-concurrency/</guid>
        <description>安全并高效地处理并发是Rust的主要目标之一。Rust使用所有权与类型系统可以同时处理内存安全与并发安全问题。
线程（Thread） // 使用spawn建立线程，使其运行一个闭包 let handle = thread::spawn(|| { for i in 1..10 { println!(&amp;#34;hi number {} from the spawned thread!&amp;#34;, i); } }); // 使用join等待线程结束 handle.join().unwrap(); // 使用sleep令当前线程休眠 thread::sleep(Duration::from_millis(1)); // 为了使线程闭包能够使用外部变量，需要使用move关键字移动所有权 let v = vec![1, 2, 3]; let handle = thread::spawn(move || { println!(&amp;#34;Here&amp;#39;s a vector: {:?}&amp;#34;, v); }); 通道 通过消息传递来进行安全的并发是一种越来越流行的思想。因此Rust标准库中实现了通道，它可以由sender发送数据给receiver。
// 建立通道，获得sender与receiver let (tx, rx) = mpsc::channel(); // 在新线程中使用sender发送数据，注意需要将sender移动至新线程 thread::spawn(move || { let val = String::from(&amp;#34;Hi&amp;#34;); // 为了保证安全，使用通道发送数据时，数据被移动 tx.</description>
      </item>
    
      <item>
        <title>std::optional、std::variant与std::any</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/optional-variant-any/</link>
        <pubDate>Fri, 09 Jun 2023 00:37:27 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/optional-variant-any/</guid>
        <description>C++17中提出了以下三种数据类型用于更加安全、方便地处理可变数据。
std::optional 类模板std::optional管理一个可选的容纳值，该值既可以存在也可以不存在。虽然直接使用指针就可以实现相同的功能，但是容易引发内存泄漏或二次释放等问题。其它实现方式（如使用std::pair&amp;lt;T,bool&amp;gt;）语法复杂且效率低下，而std::optional可以简单、高效地处理此问题。
// 初始化为不包含值 std::optional&amp;lt;int&amp;gt; opt1; std::optional&amp;lt;int&amp;gt; opt2(std::nullopt); std::optional&amp;lt;int&amp;gt; opt3 = std::nullopt; // 初始化为包含值 std::optional&amp;lt;int&amp;gt; op4(1); std::optional&amp;lt;int&amp;gt; op5 = 2; std::optional&amp;lt;int&amp;gt; op6 = std::make_optional&amp;lt;int&amp;gt;(3); // 判断是否包含值 if (opt1.has_value()) { // 可使用*或-&amp;gt;操作符访问包含的值，但是需要自行判断是否包含值 std::cout &amp;lt;&amp;lt; &amp;#34;opt1: &amp;#34; &amp;lt;&amp;lt; *opt1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } // 实现了bool运算符，表示是否包含值 if (opt1) { std::cout &amp;lt;&amp;lt; &amp;#34;opt1: &amp;#34; &amp;lt;&amp;lt; *opt1 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; } // 使用value成员函数获取包含的值，如果不包含值则抛出异常 try { int n = opt1.value(); } catch (const std::exception &amp;amp;e) { std::cout &amp;lt;&amp;lt; e.</description>
      </item>
    
      <item>
        <title>十一、标准库 - 其它</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/std-lib-misc/</link>
        <pubDate>Sun, 26 Mar 2023 17:07:48 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/std-lib-misc/</guid>
        <description>路径 使用std::path中的Path与PathBuf表示系统路径。其中Path是不可变版本，PathBuf为可变版本。
// 建立Path后不可变 let path = Path::new(&amp;#34;.&amp;#34;); // 从字符串建立PathBuf let mut buf = PathBuf::from(&amp;#34;.&amp;#34;); // 将Path转换为PathBuf let mut buf = path.to_path_buf(); // 修改PathBuf buf.push(&amp;#34;a&amp;#34;); buf.push(&amp;#34;b.txt&amp;#34;); buf.set_file_name(&amp;#34;c.tar&amp;#34;); buf.set_extension(&amp;#34;zip&amp;#34;); 文件I/O // 打开文件用于读取 let mut file = File::open(&amp;amp;path).unwrap(); // 读取文件内容到String let mut s = String::new(); file.read_to_string(&amp;amp;mut s).unwrap(); // 建立文件用于写入 let mut file = File::create(&amp;amp;path).unwrap(); // 将字符串写入文件 file.write_all(&amp;#34;content&amp;#34;.as_bytes()).unwrap(); 子进程 使用std::process::Command执行命令建立子进程。可以使用管道与其交互，等待执行完成并获取返回值。
let output = Command::new(&amp;#34;rustc&amp;#34;) // 要执行的命令 .arg(&amp;#34;--version&amp;#34;) // 参数 .output() // 等待执行完毕并获取结果 .</description>
      </item>
    
      <item>
        <title>形参包</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/parameter-pack/</link>
        <pubDate>Fri, 09 Jun 2023 20:58:23 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/parameter-pack/</guid>
        <description>模板形参包是接受零个或多个模板实参（非类型、类型或模板）的模板形参。函数模板形参包是接受零个或多个函数实参的函数形参。至少有一个形参包的模板被称作变参模板。
定义 变参类模板可用任意数量的模板实参实例化：
template &amp;lt;class... Types&amp;gt; struct Tuple {}; Tuple&amp;lt;&amp;gt; t0; // Types不包含实参 Tuple&amp;lt;int&amp;gt; t1; // Types包含一个实参：int Tuple&amp;lt;int, float&amp;gt; t2; // Types包含两个实参：int与float Tuple&amp;lt;0&amp;gt; error; // 错误：0不是类型 变参函数模板可用任意数量的函数实参调用（模板实参通过模板实参推导规则进行推导）：
template &amp;lt;class... Types&amp;gt; void f(Types... args) {} f(); // args不包含实参 f(1); // args包含一个实参：int f(2, 1.0); // args包含两个实参：int与double 在类模板中，模板形参包必须是模板形参列表的最后一个形参。在函数模板中，模板参数包可以在列表中稍早出现，只要其后的所有形参均可从函数实参推导或拥有默认实参即可：
// 正确，Ts在结尾 template &amp;lt;typename U, typename... Ts&amp;gt; struct valid; // 错误，Ts不在结尾 template &amp;lt;typename... Ts, typename U&amp;gt; struct invalid; // 正确，可以推导U template &amp;lt;typename... Ts, typename U, typename = void&amp;gt; void valid(U, Ts.</description>
      </item>
    
      <item>
        <title>十二、错误处理</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/error-handling/</link>
        <pubDate>Mon, 27 Mar 2023 11:35:30 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/error-handling/</guid>
        <description>panic 最简单的错误处理方式是使用panic!宏，它简单地打印错误并退出程序。
panic!(&amp;#34;crash and burn&amp;#34;); abort/unwind 处理panic有两种方式，可以通过编译器参数或配置文件的方式设置。默认为unwind
unwind：回溯调用栈并进行清理工作 abort：立即退出 Option 在Rust中，如果一个函数返回类型T，则它必须返回一个变量，不能返回空（类似NULL或nullptr），这样可以避免用户不检查空指针造成错误。如果确实需要返回空，则可以使用Option。Option是std库提供的一个枚举类型。Option&amp;lt;T&amp;gt;的取值为以下二者之一：
Some(T)：包含一个T类型的元素 None：不包含任何元素 编译器会强制用户处理值为None的情况，从而提高安全性。Option的操作方式有：
match：与其它枚举的处理方式相同，需要处理所有可能情况 解包：为Some时获取其值，为None时执行不同操作 unwrap：为None时panic expect：为None时使用自定义信息报错 ?：为None时使当前所在函数返回None or：为None时返回另一值。链式、立即 or_else：为None时调用函数获取值并返回。链式、延迟 get_or_insert：为None时插入值。立即 get_or_insert_with：为None时调用函数获取值并插入。延迟 使用combinator进行后续操作： map：有值则对其进行操作，否则返回None and_then：有值则解包其值并进行操作，否则返回None Result Option只返回了错误，但是并不知道错误的原因。Result加强了这一点。一个Result&amp;lt;T, E&amp;gt;的取值为以下二者之一：
Ok(T)：成功，并返回一个T类型的值 Err(E)：失败，并返回一个E类型错误 Result同样可以使用match, unwrap, ?, map, and_then等进行操作。</description>
      </item>
    
      <item>
        <title>文件系统库</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/filesystem-lib/</link>
        <pubDate>Fri, 09 Jun 2023 22:11:36 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/filesystem-lib/</guid>
        <description>C++17从boost引入了文件系统库std::filesystem，提供在文件系统及其组件，例如路径、常规文件与目录上进行操作的方法。
path 类型path的对象表示文件系统上的路径，其中包含许多对路径进行操作的成员函数。
namespace fs = std::filesystem; fs::path p1 = &amp;#34;/path/to/file&amp;#34;; // 使用字符序列构造路径 fs::path p2(&amp;#34;/path/to/dir&amp;#34;); // 使用字符序列构造路径 fs::path p3(p1); // 复制构造路径 p3 = &amp;#34;/path/to/another/file&amp;#34;; // 赋值 p2 /= &amp;#34;dir1&amp;#34;; // 使用/=拼接路径，加入分隔符 p2 += &amp;#34;dir2&amp;#34;; // 使用+=拼接路径，不加入分隔符 fs::path p4 = p2 / &amp;#34;dir3&amp;#34;; // 使用/拼接路径，加入分隔符 p1.filename(); // 获取文件名 p2.stem(); // 获取文件名主干部分（不含扩展名） p3.extension(); // 获取扩展名 p1.has_filename(); // 检查filename()是否为空 p2.has_stem(); // 检查stem()是否为空 p3.has_extension(); // 检查extension()是否为空 p1.remove_filename(); // 删除文件名 p2.replace_filename(&amp;#34;foo&amp;#34;); // 替换文件名 p3.replace_extension(&amp;#34;.bar&amp;#34;); // 替换扩展名 p1.</description>
      </item>
    
      <item>
        <title>十三、迭代器</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/iterators/</link>
        <pubDate>Tue, 28 Mar 2023 17:38:06 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/iterators/</guid>
        <description> 使用迭代器处理系列数据 使用迭代器可以对一系列数据依次进行处理。直到使用迭代器时，它不产生任何影响。
let v1 = vec![1, 2, 3]; // 获取Vec的迭代器 let v1_iter = v1.iter(); // 在for-in循环中使用迭代器 for val in v1_iter { println!(&amp;#34;Got: {}&amp;#34;, val); } 迭代器特性 迭代器需要实现类似如下的特性：
pub trait Iterator { type Item; fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;; } 消耗适配器 指会消耗掉迭代器的方法，调用这些方法后就不能再使用迭代器。
let v1 = vec![1, 2, 3]; let v1_iter = v1.iter(); let total: i32 = v1_iter.sum(); 迭代器适配器 指会生成其它迭代器的方法，它们并不消耗原来的迭代器。
let v1: Vec&amp;lt;i32&amp;gt; = vec![1, 2, 3]; v1.iter().map(|x| x + 1); </description>
      </item>
    
      <item>
        <title>日期时间库</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/datetime-lib/</link>
        <pubDate>Fri, 09 Jun 2023 23:16:33 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/datetime-lib/</guid>
        <description>std::chrono是源于boost的C++新时间库，其中包含3个主要类型以及一些辅助函数。
时间间隔 类模板std::chrono::duration用于表示时间间隔。其定义如下：
template&amp;lt; class Rep, class Period = std::ratio&amp;lt;1&amp;gt; &amp;gt; class duration; 其中，Rep为计次数的算术类型，可为整型、浮点型；Period为计次周期，为分数类型（std::ratio），单位为秒。例如，如果Period为std::ratio&amp;lt;1, 1000&amp;gt;，则表示计次周期为毫秒。每个duration对象包含一个Rep类型的次数，可用count()成员函数获取。次数×周期即为duration对象表示的时间间隔。常用的duration类型已经预定义：
nanoseconds：duration&amp;lt;至少64位的有符号整数类型, std::nano&amp;gt; microseconds：duration&amp;lt;至少55位的有符号整数类型, std::micro&amp;gt; milliseconds：duration&amp;lt;至少45位的有符号整数类型, std::milli&amp;gt; seconds：duration&amp;lt;至少35位的有符号整数类型, std::ratio&amp;lt;1&amp;gt;&amp;gt; minutes：duration&amp;lt;至少29位的有符号整数类型, std::ratio&amp;lt;60&amp;gt;&amp;gt; hours：duration&amp;lt;至少23位的有符号整数类型, std::ratio&amp;lt;3600&amp;gt;&amp;gt; 其中，std::nano为std::ratio&amp;lt;1, 1000000000&amp;gt;，std::micro为std::ratio&amp;lt;1, 1000000&amp;gt;，std::milli为std::ratio&amp;lt;1, 1000&amp;gt;。C++20还添加了days、weeks、months和years。
// 10秒 std::chrono::seconds ten_seconds(10); // 5小时 std::chrono::hours five_hours(5); 时间间隔字面值 C++14中添加了一些字面值后缀操作符，可以方便地生成时间间隔字面值：
h：小时 min：分钟 s：秒 ms：毫秒 us：微妙 ns：纳秒 using namespace std::chrono_literals; auto two_hours = 2h; auto five_minutes = 5min; 时间间隔转换 不同单位的时间间隔之间可以相互转换，转换规则为：
当整数时间间隔相互转换且源间隔单位可被目标间隔单位整除，或浮点时间间隔相互转换时，不会发生精度损失，可使用duration类的构造函数隐式转换 浮点时间间隔转整数时间间隔时，如果浮点值为NaN，无穷或相对整数间隔单位来说过大时，会出现未定义行为 其它情况（浮点时间间隔转整数时间间隔，或整数时间间隔相互转换但源间隔单位不能被目标间隔单位整除）下，会发生截断造成精度损失，情况与static_cast相同 // high_resolution_clock使用最小时间单位，且为整数时间间隔 auto t1 = std::chrono::high_resolution_clock::now(); // .</description>
      </item>
    
      <item>
        <title>十四、模式与匹配</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/patterns-and-matching/</link>
        <pubDate>Wed, 29 Mar 2023 21:42:31 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/patterns-and-matching/</guid>
        <description>模式是Rust的一种特殊语法，用于对类型的结构进行匹配。一个模式由若干以下项组成：
字面值 解构的数组、枚举、结构体或元组 变量 通配符 占位符 在模式有效的范围内，它描述了数据的形状。程序将值与模式进行匹配，以确定它是否有正确的形状，并决定是否进一步执行一段代码。
可以使用模式的位置 match分支 在match中使用模式要求穷举所有可能性，一种保证穷举的方法是在最后一个分支处理所有剩余所有可能性。使用_可以匹配任何可能性并且不绑定值，所以一般用在最后一个分支。
match x { None =&amp;gt; None, Some(i) =&amp;gt; Some(i + 1), } if-let条件表达式 if-let/else-if/else-if-let可以混用。使用if-let的缺点是如果不在最后使用else，则不能穷举所有情况。
if let Some(color) = favorite_color { println!(&amp;#34;Using your favorite color, {color}, as the background&amp;#34;); } else if is_tuesday { println!(&amp;#34;Tuesday is green day!&amp;#34;); } else if let Ok(age) = age { if age &amp;gt; 30 { println!(&amp;#34;Using purple as the background color&amp;#34;); } else { println!(&amp;#34;Using orange as the background color&amp;#34;); } } else { println!</description>
      </item>
    
      <item>
        <title>并发库</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/thread-and-synchronization/</link>
        <pubDate>Sat, 10 Jun 2023 11:47:09 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/thread-and-synchronization/</guid>
        <description>线程 C++11引入了与操作系统无关的std::thread类，可以使用统一的方式创建线程。C++20提供了std::jthread类，在std::thread的基础上增加了自动合并与外部请求终止的功能。
auto func = []() { for (int i = 0; i &amp;lt; 10; ++i) std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34;; std::cout &amp;lt;&amp;lt; std::endl; }; std::thread t(func); // 创建一个线程并开始执行 if (t.joinable()) // 检查线程可否被合并 t.join(); // 阻塞等待线程结束 if (t.joinable()) t.detach(); // 将线程和线程对象分离，无法再与线程交互 互斥 使用互斥避免多个线程同时访问共享资源，这可以避免数据竞争，并提供线程间的同步支持。
互斥量 C++并发库中提供以下互斥量：
mutex：基本互斥量 timed_mutex：带时限互斥量 recursive_mutex：能被同一线程递归锁定的互斥量 recursive_timed_mutex：带时限且能被同一线程递归锁定的互斥量 shared_mutex：共享互斥量 shared_timed_mutex：带时限共享互斥量 std::mutex mut; // 互斥量 std::vector&amp;lt;int&amp;gt; nums; // 共享变量 auto func = [&amp;amp;](int k) { mut.lock(); // 对互斥量加锁 nums.</description>
      </item>
    
      <item>
        <title>十五、生命周期</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/lifetime/</link>
        <pubDate>Thu, 30 Mar 2023 21:57:18 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/lifetime/</guid>
        <description>生命周期是编译器的借用检查器用来保证所有借用都有效的一个概念。一个变量的生命周期从它被创建开始到它被销毁结束。
fn main() { let i = 3; // i生命周期开始 ─────────────────────────────┐ // │ { // │ let borrow1 = &amp;amp;i; // 借用`borrow1`生命周期开始 ──────┐│ // ││ println!(&amp;#34;borrow1: {}&amp;#34;, borrow1); // ││ } // `borrow1`生命周期结束 ─────────────────────────────┘│ // │ // │ { // │ let borrow2 = &amp;amp;i; // 借用`borrow2`生命周期开始 ──────┐│ // ││ println!(&amp;#34;borrow2: {}&amp;#34;, borrow2); // ││ } // `borrow2`生命周期结束 ─────────────────────────────┘│ // │ } // i生命周期结束 ────────────────────────────────────────┘ 显式标注 借用检查器使用显式生命周期标注来决定引用需要有效多久。
// foo具有一个生命周期参数&amp;#39;a，foo的生命周期不能超过&amp;#39;a foo&amp;lt;&amp;#39;a&amp;gt; // 一个带生命周期标注的类型 &amp;amp;&amp;#39;a T // 使用多个生命周期参数，foo的生命周期不能超过&amp;#39;a或&amp;#39;b foo&amp;lt;&amp;#39;a, &amp;#39;b&amp;gt; 在函数中使用 带有生命周期的函数签名具有一些约束：</description>
      </item>
    
      <item>
        <title>十六、宏</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/macros/</link>
        <pubDate>Fri, 31 Mar 2023 19:32:52 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/macros/</guid>
        <description>分类 Rust中的宏分为两类：使用macro_rules!声明的声明式宏与以下3种过程宏：
自定义#[derive]宏：可以使用derive属性在结构体与枚举上添加指定代码 类属性宏：自定义可以在任何项目上使用的属性 类函数宏：看起来像函数但是在它们的参数上进行操作 为什么使用宏 DRY（不要重复自己）：可以避免重复同样的代码 DSL（领域特定语言）：可以定义用于特定用途的自定义语法 Variadic（可变参数函数）：可以定义接收任意数量参数的接口（类似函数），例如println! 宏与函数的不同 宏是用代码写其它代码的方式，即元编程。在编译前，编译器会将宏展开并进行编译。与C等语言的宏不同，Rust的宏不是简单的字符串展开，而是会生成抽象语法树，这避免了无法预期的问题。宏与函数都是用于减少代码量，但是宏有一些函数没有的能力。
函数必须指定参数的个数与类型，宏可以接收任意数量参数 宏在编译前展开，函数在运行期间调用，所以宏可以做许多函数无法做的事情，例如在一个类型上实现一个特性 宏的缺点是更加复杂，难于理解与维护，因为是在间接地用代码编写代码 宏必须先定义并加引入作用域才能使用，而函数可以在任何地方定义与调用 使用macro_rules!进行元编程的声明式宏 声明式宏允许编写一个类似match的结构，在编译时，如果传入值匹配其中一个分支，则将宏替换为对应的代码。使用macro_rules!定义宏：
// 定义宏 macro_rules! say_hello { () =&amp;gt; { println!(&amp;#34;Hello!&amp;#34;); }; } // 调用宏 say_hello!() 语法 参数与指示符 宏的参数定义方式如下，每个参数带有前缀$，冒号后为其指示符，表示该参数的类型。
($func_name:ident) 可能的指示符有：
block：块 expr：表达式 ident：标识符，如变量、函数名 item：项，如函数、结构体、模块等 literal：字面值常量 pat：模式 path：路径 stmt：语句 tt：语法树 ty：类型 vis：visibility限定词 完整的列表在这里。
重载 宏可以重载，使用不同的参数组合。
macro_rules! test { // 一个参数组合 ($left:expr; and $right:expr) =&amp;gt; { println!(&amp;#34;{:?} and {:?} is {:?}&amp;#34;, stringify!($left), stringify!($right), $left &amp;amp;&amp;amp; $right) }; // 另一个参数组合 ($left:expr; or $right:expr) =&amp;gt; { println!</description>
      </item>
    
      <item>
        <title>十七、不安全操作</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/unsafe-operations/</link>
        <pubDate>Sat, 01 Apr 2023 11:34:52 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/unsafe-operations/</guid>
        <description>Rust编译器的静态检查可以保证代码是非常安全的，但是它过于严格，拒绝了一些可能有效的代码。因此如果确定需要使用这些代码，则要使用不安全操作告诉编译器放松条件。此外，如果要执行一些底层系统级操作，则必须要使用不安全操作。
解引裸指针 引用是由编译器保证总是有效的，因此可以安全地使用。在不安全的Rust中，有两种新的裸指针类型：*const T与*mut T。使用裸指针在放弃了安全性保证的同时，可以得到极大的性能提升或与其它语言/硬件进行交互的能力。与引用和智能指针不同，裸指针有以下特点：
允许忽略借用规则，同时可以有任意个指针指向同一地址 不保证裸指针指向有效数据 可以为空 不实现自动清理 以下代码从引用建立裸指针，可知指向的数据是有效的：
let mut num = 5; // 建立不可变指针 let r1 = &amp;amp;num as *const i32; // 建立可变指针 let r2 = &amp;amp;mut num as *mut i32; 以下代码从任意内存位置建立指针，不能保证指向有效数据：
let address = 0x012345usize; let r = address as *const i32; 建立裸指针本身是安全的，但是由于指向的数据不一定有效，所以解引裸指针是不安全的：
unsafe { println!(&amp;#34;r1 is: {}&amp;#34;, *r1); println!(&amp;#34;r2 is: {}&amp;#34;, *r2); } 调用不安全函数或方法 在函数声明前添加unsafe关键字声明不安全函数，这意味着调用者需要自行保证调用的正确性。调用此类函数需要在unsafe块中进行。
// 声明unsafe函数 unsafe fn dangerous() {} // 调用unsafe函数 unsafe { dangerous(); } 可以将不安全代码封装在安全函数中，无需将整个函数标记为不安全。</description>
      </item>
    
      <item>
        <title>十八、代码组织</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/code-organization/</link>
        <pubDate>Sun, 02 Apr 2023 22:14:35 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/code-organization/</guid>
        <description>Rust提供了一系列特性用于管理代码的组织结构，包括：
Package（包）：Cargo提供的可以建立、测试与分享箱的结构 Crate（箱）：模块组成的树，构成一个库或可执行文件 Module（模块）与use（引入）：用于控制代码结构、作用域与路径的隐私性 Path（路径）：命名结构体、函数或模块的方式 Crate（箱） 箱是编译器每次编译的最小单位。箱分为两类：
二进制箱：是可以编译为可执行文件的程序，包含main函数 库箱：不包含main函数，用于分享功能 每个箱从一个根文件开始编译，可能包含多个文件。
Package（包） 包是包管理器Cargo提供的结构，它包含一个配置文件Cargo.toml。一个包可以包含多个箱，但是最多有一个库箱。默认情况下，src/main.rs是二进制箱的根文件，src/lib.rs是库箱的根文件。
Module（模块） 使用模块可以对代码进行组织以提高可读性与可用性，每个箱都由一组树状的模块组成。
使用以下命令建立一个库：
cargo new restaurant --lib 在src/lib.rs中添加以下代码：
mod front_of_house { mod hosting { fn add_to_waitlist() {} fn seat_at_table() {} } mod serving { fn take_order() {} fn serve_order() {} fn take_payment() {} } } 以上代码形成的模块树如下，其中根自动命名为crate：
crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment Path（路径） 使用路径在模块树中引用项目 路径有两种形式：</description>
      </item>
    
      <item>
        <title>十九、测试</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/tests/</link>
        <pubDate>Mon, 03 Apr 2023 12:54:41 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/tests/</guid>
        <description>测试是检查其它代码是否正常工作的Rust函数。典型的测试函数执行以下三个动作：
设置需要的数据和状态 运行测试代码 检查结果是否符合预期 如何编写测试函数 使用cargo new建立一个库项目时，会自动生成一个测试模块。测试函数前需要添加#[test]属性，之后使用cargo test命令会自动运行测试。
#[cfg(test)] mod tests { #[test] fn it_works() { let result = 2 + 2; assert_eq!(result, 4); } } 使用assert!宏检查结果 assert!用于保证条件为true，为true则继续执行程序，为false则调用panic!。
#[derive(Debug)] struct Rectangle { width: u32, height: u32, } impl Rectangle { fn can_hold(&amp;amp;self, other: &amp;amp;Rectangle) -&amp;gt; bool { self.width &amp;gt; other.width &amp;amp;&amp;amp; self.height &amp;gt; other.height } } #[cfg(test)] mod tests { use super::*; // 此测试会成功 #[test] fn larger_can_hold_smaller() { let larger = Rectangle { width: 8, height: 7, }; let smaller = Rectangle { width: 5, height: 1, }; assert!</description>
      </item>
    
      <item>
        <title>二十、其他</title>
        <link>https://zqwang-cn.github.io/rust-study-notes/others/</link>
        <pubDate>Tue, 04 Apr 2023 13:26:25 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/rust-study-notes/others/</guid>
        <description>属性（Attribute） 属性是提供给模块、箱或其它项目的元数据。
dead_code 用于关闭编译器对于无用代码的警告。
#[allow(dead_code)] fn unused_function() {} crate_type与crate_name 用于指定箱的类型与名称。
#![crate_type = &amp;#34;lib&amp;#34;] #![crate_name = &amp;#34;rary&amp;#34;] cfg 用于检查设置。
// 在符合条件时才编译 #[cfg(target_os = &amp;#34;linux&amp;#34;)] fn are_you_on_linux() { println!(&amp;#34;You are running linux!&amp;#34;); } // 在程序中使用宏获取设置 if cfg!(target_os = &amp;#34;linux&amp;#34;) { println!(&amp;#34;Yes. It&amp;#39;s definitely linux!&amp;#34;); } else { println!(&amp;#34;Yes. It&amp;#39;s definitely *not* linux!&amp;#34;); } 可以使用自定义属性：
#[cfg(some_condition)] fn conditional_function() { println!(&amp;#34;condition met!&amp;#34;); } 但是需要在编译时手动传入：
rustc --cfg some_condition custom.rs &amp;amp;&amp;amp; ./custom 面向对象编程（OOP）特点 怎样才算OOP语言这一点并没有明确的共识。虽然Rust的语法与普通的OOP语言相差较大，但是它仍然具有OOP的主要特点。
对象包含数据与行为：结构与枚举中包含数据，使用impl块可以为它们实现方法，因此可以将结构和枚举视为对象 封装：使用pub可以控制结构内部变量/方法的可见性 继承：继承的作用是代码复用与多态，虽然Rust本身并不提供继承机制，但是通过使用特性可以实现这两个功能 原始标识符 原始标识符允许使用关键字作为标识符。这在Rust引入新关键字，而某些旧版本代码使用了同名标识符时非常有用。</description>
      </item>
    
      <item>
        <title>其他特性</title>
        <link>https://zqwang-cn.github.io/cpp-new-features/other-features/</link>
        <pubDate>Sat, 10 Jun 2023 15:17:07 +0800</pubDate>
        
        <guid>https://zqwang-cn.github.io/cpp-new-features/other-features/</guid>
        <description>nullptr C++11以前通常用NULL表示空指针，但是NULL是用#define定义的，通常定义为0：
#define NULL 0 因此实际上它与数值0没有区别，这在重载时会引发混乱。如果定义以下两个重载函数：
void foo(char *); void foo(int); 在用NULL作为参数调用时：
foo(NULL); 用户应该希望调用char*版本，然而由于NULL实际上是0，会导致调用int版本。为了解决这一问题，C++11引入了nullptr关键字用来专门表示空指针。它是std::nullptr_t类型的纯右值，可以隐式转换为任何指针类型及任何成员指针类型。使用nullptr调用上述函数：
foo(nullptr); 可以正确调用char*版本。
基于范围的for循环 C++11引入了基于范围的for循环，它相当于其它语言的for-each或for-in循环，可以使循环代码更加简洁。
std::vector&amp;lt;int&amp;gt; arr(5, 100); for (auto &amp;amp;i : arr) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; } 条件表达式中支持初始化语句 c++17中支持在if或者switch语句中进行初始化，这个能力的出现能够让代码更加简洁。
std::map&amp;lt;int, std::string&amp;gt; c = {{1, &amp;#34;a&amp;#34;}}; if (auto res = c.insert(std::make_pair(2, &amp;#34;b&amp;#34;)); !res.second) { std::cout &amp;lt;&amp;lt; &amp;#34;key 1 exist&amp;#34; &amp;lt;&amp;lt; std::endl; } else { std::cout &amp;lt;&amp;lt; &amp;#34;insert success, value:&amp;#34; &amp;lt;&amp;lt; res.first-&amp;gt;second &amp;lt;&amp;lt; std::endl; } 非成员函数std::begin()与std::end() C++标准库中的容器都实现了begin()与end()成员函数，用于获取首尾迭代器。例如：</description>
      </item>
    
      <item>
        <title>使用nvJPEG加速解码JPG图像</title>
        <link>https://zqwang-cn.github.io/posts/use-nvjpeg-to-accelerate-jpg-image-decoding/</link>
        <pubDate>Fri, 30 Dec 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/use-nvjpeg-to-accelerate-jpg-image-decoding/</guid>
        <description>背景 在读取JPG图像时，需要先对图像进行解码。一般的图像库（如opencv）采用CPU进行解码，如果对速度有很高要求则需要另外实现。
nvJPEG是英伟达提供的可以使用GPU加速的JPG解码库，它包含在较高版本的CUDA（&amp;gt;10.0）中，如果使用低版本CUDA，则需要另外安装。
步骤 1. 假设待解码的本地文件为test.jpg，首先将其二进制数据读入内存
// 以二进制方式打开文件 std::ifstream in_fs(&amp;#34;test.jpg&amp;#34;, std::ifstream::binary); // 获取文件大小 in_fs.seekg(0, std::ios::end); auto in_size = in_fs.tellg(); // 读入全部数据（使用vector避免手动申请/释放空间） std::vector&amp;lt;uchar&amp;gt; in_buf(in_size); in_fs.seekg(0); in_fs.read((char*)in_buf.data(), in_size); 2. 初始化nvJPEG，建立handle与state
nvjpegHandle_t handle; nvjpegJpegState_t state; nvjpegCreateSimple(&amp;amp;handle); nvjpegJpegStateCreate(handle, &amp;amp;state); 3. 获取图像长宽、通道数、subsampling等信息
int widths[NVJPEG_MAX_COMPONENT]; int heights[NVJPEG_MAX_COMPONENT]; int channels; nvjpegChromaSubsampling_t subsampling; nvjpegGetImageInfo(handle, in_buf.data(), in_size, &amp;amp;channels, &amp;amp;subsampling, widths, heights); 4. 设置输出参数并解码
解码时，除了需要传入输入数据及大小外，还需要指定输出格式（nvjpegOutputFormat_t）及输出图像信息（nvjpegImage_t，包含每个通道的行宽度pitch，以及每个通道的输出缓存地址channel）
此处指定输出格式为NVJPEG_OUTPUT_BGRI，该格式将所有输出写入channel[0]中，格式为&amp;quot;BGRBGRBGR&amp;hellip;&amp;quot;，因此picth[0]为图像宽度×3，channel[0]缓存大小至少应为图像长度×图像宽度×3。如果需要使用其它格式请参考官方文档
// 计算输出行宽度与总大小 int mul = 3; int out_step = widths[0] * mul; int out_size = out_step * heights[0]; // 设置输出信息，并在显存上申请缓存 nvjpegImage_t out_buf; out_buf.</description>
      </item>
    
      <item>
        <title>cv::Mat通道顺序转换（HWC转CHW）</title>
        <link>https://zqwang-cn.github.io/posts/cv-mat-channel-transpose-hwc-to-chw/</link>
        <pubDate>Fri, 29 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/cv-mat-channel-transpose-hwc-to-chw/</guid>
        <description> 简介 在深度学习的图像前处理中，一般会将HWC格式的图像转换为CHW格式，因此需要进行通道顺序转换操作。不同的框架提供了不同的操作：
在python版OpenCV中，使用numpy.transpose（OpenCV本身不支持） 在pytorch中，使用torch.permute 在tensorflow中，使用tf.transpose C++版OpenCV中进行HWC转CHW C++版本OpenCV不提供通道转换操作，可以使用以下方法进行HWC转CHW（不支持任意转换操作）：
// 原始图像，尺寸为(h, w, c) cv::Mat image; int h = image.rows; int w = image.cols; int c = image.channels(); // 尺寸转换为(h*w, c, 1)，此步骤不对内存进行修改 image = image.reshape(1, h * w); // 图像转置，尺寸变为(c, h*w, 1) image = image.t(); // 尺寸转换为(c, h, w)，此步骤不对内存进行修改 image = image.reshape(w, c); </description>
      </item>
    
      <item>
        <title>在Linux中使用微信/企业微信</title>
        <link>https://zqwang-cn.github.io/posts/use-wechat-wework-in-linux/</link>
        <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/use-wechat-wework-in-linux/</guid>
        <description>简介 通过Wine运行Windows程序 使用Docker避免复杂的Wine配置 微信 1. 首次运行
sudo docker run -d --name wechat --device /dev/snd --ipc=&amp;#34;host&amp;#34; \ -v /tmp/.X11-unix:/tmp/.X11-unix \ -v $HOME/WeChatFiles:/WeChatFiles \ -e DISPLAY=unix$DISPLAY \ -e XMODIFIERS=@im=fcitx \ -e QT_IM_MODULE=fcitx \ -e GTK_IM_MODULE=fcitx \ -e AUDIO_GID=`getent group audio | cut -d: -f3` \ -e GID=`id -g` \ -e UID=`id -u` \ bestwu/wechat 2. 停止
sudo docker stop wechat 3. 再次运行
sudo docker start wechat 企业微信 1. 首次运行
sudo docker run -d --name wework --device /dev/snd --ipc host \ -v /tmp/.</description>
      </item>
    
      <item>
        <title>使用iptables控制仅限指定IP访问指定端口</title>
        <link>https://zqwang-cn.github.io/posts/use-iptables-to-control-port-access/</link>
        <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/use-iptables-to-control-port-access/</guid>
        <description>背景 在服务器上，如果将某个端口开放使所有IP都可以访问，则可能会引起攻击或增加不必要的流量。此时可以使用iptables控制仅使需要的IP可以访问。
步骤 1. 首先禁止所有IP访问端口：
iptables -I INPUT -p tcp --dport {port} -j DROP 2. 之后将该端口开放给指定IP：
iptables -I INPUT -s {ip} -p tcp --dport {port} -j ACCEPT 其中ip可以为单一IP（如192.168.1.1），也可以为带掩码的一组IP（如192.168.1.0/24）。
3. 导入/导出规则
# 导出 iptables-save &amp;gt; {file} # 导入 iptables-restore &amp;lt; {file} 4. 重启后自动导入规则
无论直接添加的规则还是导入的规则，在重启后都不会保存，需要重新添加或导入。因此需要在/etc/rc.local中使用iptables-restore自动导入规则。
5. 使用脚本自动添加当前ssh登录ip
ip=`who | grep -o &amp;#34;[0-9]*\.[0-9]*\.[0-9]*\.&amp;#34; | tail -n 1`&amp;#34;0/24&amp;#34; port=12345 echo $ip:$port iptables -C INPUT -s $ip -p tcp --dport $port -j ACCEPT if [ $?</description>
      </item>
    
      <item>
        <title>编译OpenCV以支持CUDA功能</title>
        <link>https://zqwang-cn.github.io/posts/compile-opencv-to-support-cuda/</link>
        <pubDate>Wed, 20 Apr 2022 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/compile-opencv-to-support-cuda/</guid>
        <description> 背景 在Linux系统中，使用apt等包管理软件安装的OpenCV默认不支持CUDA，如需使用则要自行编译。
步骤 1. 从OpenCV官网下载源码，将其内容解压至opencv-{version}/。
2. 从github下载OpenCV contrib包，将其解压至opencv-{version}/opencv_contrib-{version}/。注意两个包的版本要相同。
3. 在opencv-{version}/下建立build文件夹，执行以下命令：
cd opencv-{version}/build cmake -DOPENCV_EXTRA_MODULES_PATH=../opencv_contrib-{version}/modules -DWITH_CUDA=1 .. make -j8 install 说明 在执行cmake命令时，如需其它功能，可以自行添加其它编译变量 在编译前可能需要使用apt等安装依赖 </description>
      </item>
    
      <item>
        <title>BGSLibrary背景提取库介绍</title>
        <link>https://zqwang-cn.github.io/posts/bgslibrary-introduction/</link>
        <pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/bgslibrary-introduction/</guid>
        <description>简介 BGSLibrary(Background Subtraction Library) 是一个背景减除（背景提取）库，它使用C++开发，提供Python/Matlab/Java接口，并可以跨平台使用(Windows/Ubuntu/OS X)。
安装 可以编译安装，也可以安装二进制包。但是对于python可以直接使用pip安装，非常方便：
pip install pybgs 使用 根据官方demo，使用方法十分简单（以python为例）：
import numpy as np import cv2 import pybgs as bgs algorithm = bgs.FrameDifference() video_file = &amp;#34;dataset/video.avi&amp;#34; capture = cv2.VideoCapture(video_file) while True: flag, frame = capture.read() if not flag: break img_output = algorithm.apply(frame) img_bgmodel = algorithm.getBackgroundModel() cv2.imshow(&amp;#39;video&amp;#39;, frame) cv2.imshow(&amp;#39;img_output&amp;#39;, img_output) cv2.imshow(&amp;#39;img_bgmodel&amp;#39;, img_bgmodel) if cv2.waitKey(10) == 27: break 所有算法具有相同接口，如需更换算法只需修改algorithm变量即可。
支持的算法 支持算法列表</description>
      </item>
    
      <item>
        <title>c&#43;&#43;统一函数接口返回不同类型的值</title>
        <link>https://zqwang-cn.github.io/posts/c-plusplus-unified-function-interface-return-different-types-of-value/</link>
        <pubDate>Thu, 15 Oct 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/c-plusplus-unified-function-interface-return-different-types-of-value/</guid>
        <description>假设存在以下函数：
int get_int(); float get_float(); std::string get_string(); 想要将其整合为一个函数get_value()，根据需要返回不同类型的数据。
尝试使用函数模板，在函数中根据数据类型执行不同的操作：
template &amp;lt;typename T&amp;gt; T get_value() { T ret; if (std::is_same&amp;lt;T, int&amp;gt;::value) ret = get_int(); else if (std::is_same&amp;lt;T, float&amp;gt;::value) ret = get_float(); else if (std::is_same&amp;lt;T, std::string&amp;gt;::value) ret = get_string(); return ret; } 然而这样会出现编译错误。这是由于在实际使用时，编译器会根据T的实际类型将模板实例化为一个普通函数，例如当T为int时，实例化的函数为：
int get_value() { int ret; if (std::is_same&amp;lt;int, int&amp;gt;::value) ret = get_int(); else if (std::is_same&amp;lt;int, float&amp;gt;::value) ret = get_float(); else if (std::is_same&amp;lt;int, std::string&amp;gt;::value) ret = get_string(); return ret; } 此时两个else if语句中的代码虽然永远不会执行，但是它们却不能通过编译。因此此方法无效。</description>
      </item>
    
      <item>
        <title>Anchor free检测算法概述</title>
        <link>https://zqwang-cn.github.io/posts/anchor-free-detection-algorithms-overview/</link>
        <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/anchor-free-detection-algorithms-overview/</guid>
        <description>0. Anchor based v.s. anchor free Anchor based算法 什么是anchor： 在图像中预先设置的不同大小与尺度的候选框，覆盖几乎所有位置与尺度，用于对每个位置是否存在物体进行判断。
基本步骤：Anchor based算法通常分为2步：
对每个anchor内的图像进行分类，以确定物体类型与其置信度 对置信度高的anchor边界在小范围内进行回归，以确定准确边界 Anchor free算法 顾名思义，即不使用anchor的检测算法。通常使用类似分割或关键点检测的方式直接对每个点进行处理。大致可分为2类：
密集预测（置信度与偏移量）的方法 基于关键点匹配的方法 1. 密集预测的方法 1.0 基本结构 1.1 DenseBox Huang L, Yang Y, Deng Y, et al. Densebox: Unifying landmark localization with end to end object detection[J]. arXiv preprint arXiv:1509.04874, 2015.
结构 class分支为人脸中心一个圆形区域的heatmap box分支为到边界的距离 class分支与box分支均采用L2 loss 设计用于人脸检测，类别数量C=1 特点 将图像裁剪为patch分别进行处理 使用类似编码器/解码器的结构进行多尺度特征融合 使用hard negative mining解决正负样本不平衡的问题 可以使用landmark增强效果 评价 最早的anchor free检测算法之一，最新的同类算法仍然采用大致相同的思路，只是在细节进行改进。 1.2 UnitBox Yu J, Jiang Y, Wang Z, et al.</description>
      </item>
    
      <item>
        <title>c语言&#43;&#43;操作符与函数调用的问题</title>
        <link>https://zqwang-cn.github.io/posts/c-plusplus-operator-and-function-call-problem/</link>
        <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/c-plusplus-operator-and-function-call-problem/</guid>
        <description>假设有如下c函数：
void func(int a, int b, int c) { printf(&amp;#34;%d,%d,%d\n&amp;#34;,a,b,c); } 使用如下方式调用：
int i=0; func(i++, i++, i++); 希望的输出是：
0,1,2 但是实际输出是：
2,1,0 分析原因，应该是由于c语言的参数压栈顺序为从右向左，因此实际执行的过程是：
int i = 0; int c = i; i = i + 1; int b = i; i = i + 1; int a = i; i = i + 1; func(a, b, c); 但是如果使用如下方式调用：
int i=0; func(++i, ++i, ++i); 输出却是：
3,3,3 其原因猜测是因为，与i++不同，++i操作没有生成临时变量，因此最后使用的是同一个i。其执行过程如下：
int i = 0; i = i + 1; i = i + 1; i = i + 1; func(i, i, i); 为了验证以上猜想，考虑如下调用：</description>
      </item>
    
      <item>
        <title>架设RTMP流媒体服务器并使用python进行推流</title>
        <link>https://zqwang-cn.github.io/posts/install-rtmp-server-and-push-stream-using-python/</link>
        <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zqwang-cn.github.io/posts/install-rtmp-server-and-push-stream-using-python/</guid>
        <description>1、服务器架设 服务器不一定要安装在推流程序所在的机器上，也可以安装在发送、接收双方均可访问到的第三台机器上。
安装方式可以使用docker镜像或直接编译安装。
使用docker镜像 github地址：https://github.com/alfg/docker-nginx-rtmp
安装并运行：
docker pull alfg/nginx-rtmp docker run -it -p 1935:1935 -p 8080:80 --rm alfg/nginx-rtmp 之后即可推流至：
rtmp://&amp;lt;server ip&amp;gt;:1935/stream/$STREAM_NAME 自行编译安装 # 安装依赖库 sudo apt install -y libpcre3 libpcre3-dev openssl libssl-dev zlib1g-dev # 下载nginx源码并解压 wget http://nginx.org/download/nginx-1.17.8.tar.gz tar -xf nginx-1.17.8.tar.gz # 下载nginx-rtmp-module模块源码 git clone https://github.com/arut/nginx-rtmp-module.git # 编译并安装带nginx-rtmp-module模块的nginx cd nginx-1.17.8 ./configure --add-module=../nginx-rtmp-module sudo make install 配置nginx，配置文件地址为：/usr/local/nginx/conf/nginx.conf。由于目前浏览器已经禁止使用Flash，不能直接播放rtmp流，因此可以选择添加hls配置。
worker_processes 1; events { worker_connections 1024; } rtmp { server { listen 1935; chunk_size 4096; application stream { live on; record off; # hls配置 hls on; hls_path /var/www/hls; hls_fragment 3; hls_playlist_length 60; } } } http { server { listen 80; # hls配置 location /hls { # Disable cache add_header Cache-Control no-cache; # CORS setup add_header &amp;#39;Access-Control-Allow-Origin&amp;#39; &amp;#39;*&amp;#39; always; add_header &amp;#39;Access-Control-Expose-Headers&amp;#39; &amp;#39;Content-Length&amp;#39;; # allow CORS preflight requests if ($request_method = &amp;#39;OPTIONS&amp;#39;) { add_header &amp;#39;Access-Control-Allow-Origin&amp;#39; &amp;#39;*&amp;#39;; add_header &amp;#39;Access-Control-Max-Age&amp;#39; 1728000; add_header &amp;#39;Content-Type&amp;#39; &amp;#39;text/plain charset=UTF-8&amp;#39;; add_header &amp;#39;Content-Length&amp;#39; 0; return 204; } types { application/vnd.</description>
      </item>
    
  </channel>
</rss>